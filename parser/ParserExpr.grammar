%package "ubordeaux.deptinfo.compilation.project.main";
%class "ParserExpr";
%import "ubordeaux.deptinfo.compilation.project.main.*";
%import "ubordeaux.deptinfo.compilation.project.node.*";
%import "ubordeaux.deptinfo.compilation.project.type.*";
%import "ubordeaux.deptinfo.compilation.project.environment.*";
%import "java.util.ArrayList";
%import "java.util.Iterator";


%embed {: 
	static class Events extends beaver.Parser.Events {
		public void syntaxError(Symbol token) {
			System.err.format("*** Erreur de syntaxe en ligne %d, colonne %d. Token inattendu: %s\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()),
				Terminals.NAMES[token.getId()]);
		}
	}
	
	public void semanticError(String msg, Symbol token) {
			System.err.format("*** " + msg + " ligne %d, colonne %d\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()));
		}
		
	private Environment typeEnvironment = new Environment("types");
	private Environment procedureEnvironment = new Environment("procedures");
	private StackEnvironment stackEnvironment = new StackEnvironment("local variables stack");
	private String type_declaration_name;
	
	
:};

%init {: 
	report = new Events();
:};

/////////////////////////////////////////
////////////    TERMINALS    ////////////
/////////////////////////////////////////

%terminals BEGIN, END, TYPE, STR, INT, BOOL, DOUBLE_DOT;
%terminals ARRAY, LBRACKET, RBRACKET, OF, CIRCUMFLEX;
%terminals STRUCT, LCURLY_BRACKET, RCURLY_BRACKET, COLON;
%terminals PROCEDURE, FUNCTION, LPAR, RPAR, VAR;
%terminals NEW, DISPOSE, PRINTLN, READLN, RETURN;
%terminals IF, THEN, ELSE, WHILE;
%terminals DO, SWITCH, CASE, DEFAULT;
%terminals PLUS, MINUS, TIMES, DIV;
%terminals OR, AND, INFERIOR, INFERIOR_EQ, SUPERIOR;
%terminals SUPERIOR_EQ, EQUALS, DIFF, TRUE, FALSE, NULL;
%terminals SEMI, EQ, COMMA, NOT;
%terminals IDENTIFIER, INTEGER_LIT, STRING_LIT;

//////////////////////////
////    LEFT/RIGHT    ////
//////////////////////////

%right UNARY_MINUS, CIRCUMFLEX, NOT, IF, THEN, ELSE;
%left TIMES, DIV, PLUS, MINUS;
%left OR, AND, INFERIOR, INFERIOR_EQ, SUPERIOR, SUPERIOR_EQ, EQUALS, DIFF;

/////////////////////
////   TYPEOF    ////
/////////////////////


////====Node====\\\\

%typeof statement = "Node";
%typeof structured_statement = "Node";
%typeof simple_statement = "Node";
%typeof statement_list = "Node";
%typeof argt = "Node";
%typeof procedure_definition = "Node";
%typeof procedure_expression = "Node";
%typeof case_default = "NodeCase";

////====NodeExp====\\\\

%typeof variable_access = "NodeExp";
%typeof expression = "NodeExp";

////====Integer/String====\\\\

%typeof INTEGER_LIT = "Integer";
%typeof init_enumerated_type = "Integer";
%typeof STRING_LIT = "String";
%typeof IDENTIFIER = "String";

////====Literal====\\\\

%typeof literal = "NodeLiteral";

////====TYPE====\\\\
%typeof type_declaration_head = "TypeNamed";
%typeof type_declaration = "Type";
%typeof type_declaration_part, type = "Type";
%typeof index_type = "Type";
%typeof range_type = "Type";
%typeof subrange_type = "Type";
%typeof variable_declaration_part = "Type";
%typeof feature_type = "TypeFeature";

////====LIST====\\\\

%typeof type_declaration_list = "TypeList";
%typeof variable_declaration, variable_declaration_list = "NodeList";
%typeof case_statement = "NodeList";
%typeof expression_part = "NodeList";
%typeof expression_list = "NodeList";
%typeof argt_list = "NodeList";
%typeof feature_list_type = "TypeFeatureList";
%typeof case_statement_list = "NodeCaseList";
%typeof identifier_list = "IdentifierList";
%typeof procedure_definition_list = "NodeList";


///////////////////////////////////////
///////////    PROGRAMME    ///////////
///////////////////////////////////////

%goal program;

program =
	push_stack
	type_declaration_part		
	variable_declaration_part		
	procedure_definition_part		
	BEGIN
	statement_list.l
	END
	pop_stack
	{: return l; :}
	;

	push_stack = {:stackEnvironment.push_stack();return new Symbol(0);:};
	pop_stack = {:stackEnvironment.pop_stack();return new Symbol(0);:};
////////////////////////////////////////////////
//////    DECLARATION DES TYPES NOMMES    //////
////////////////////////////////////////////////

type_declaration_part =
	/* empty */
	|TYPE type_declaration_list
	;

type_declaration_list =
	type_declaration_list.list type_declaration.t		{: list.add(t); return list; :}
	| type_declaration.t								{: TypeList list = new TypeList(t);  return list; :}
	;

type_declaration =
	type_declaration_head.name EQ type.t SEMI			
	
	{:  
		typeEnvironment.putVariable(name.get_name(),t);
		return new TypeFeature(name.get_name(),t);
	:}	
	;
	
type_declaration_head =
	IDENTIFIER.name 									{: return new TypeNamed(name); :}
	;

////////////////////////////////////////
//////    DEFINITION DES TYPES    //////
////////////////////////////////////////

type=
	simple_type
	| named_type
	| index_type
	| array_type
	| pointer_type
	| structure_type
	;

simple_type =
	STR						{: return new TypeString(); :}
	| INT					{: return new TypeInt(); :}
	| BOOL					{: return new TypeBoolean(); :}
	;

named_type =
	IDENTIFIER.name			{: return new TypeNamed(name); :}
	;

index_type =
	enumerated_type
	| subrange_type
	;

enumerated_type =
	init_enumerated_type LPAR identifier_list.t_list RPAR
		{: 
			Iterator<String> it = t_list.iterator();
			int i = 0;
			while(it.hasNext()) {
			String x =  it.next();
			typeEnvironment.put_enum_value(x,i);
			stackEnvironment.putVariable(x,new TypeInt(i));
			i++;
			}
			//typeEnvironment.put_enum_value(t_list.first(),0);
			//typeEnvironment.put_enum_value(t_list.last(),t_list.size()-1);
			return new TypeEnumRange(new TypeItemEnum(0,t_list.first()),new TypeItemEnum(t_list.size()-1,t_list.last()));
		:}
	;
	
init_enumerated_type = 
							{:	return new TypeEnumRange();	:}
	;

subrange_type =
	INTEGER_LIT.min DOUBLE_DOT INTEGER_LIT.max				{: return new TypeArrayRange(new TypeInt(min), new TypeInt(max)); :}
	| IDENTIFIER.min DOUBLE_DOT IDENTIFIER.max				
		{: 
		int v_min = typeEnvironment.get_enum_value(min);
		int v_max = typeEnvironment.get_enum_value(max);
		return new TypeArrayRange(new TypeInt(v_min), new TypeInt(v_max)); 
		:}
	;

array_type =
	ARRAY LBRACKET range_type.t1 RBRACKET OF type.t2			{: return new TypeArray(t1,t2); :}
	;

range_type =
	enumerated_type
	| subrange_type
	| named_type
	;

pointer_type =
	CIRCUMFLEX type.t											{: return new TypePointer(t); :}
	;

structure_type =
	STRUCT LCURLY_BRACKET feature_list_type.t RCURLY_BRACKET	{: return new TypeStruct(t); :}
	;

feature_list_type =
	feature_list_type.list feature_type.t						{: list.add(t); return list; :}
	| feature_type.t											{: TypeFeatureList list = new TypeFeatureList(); list.add(t); return list; :}
	;
	

feature_type =
	IDENTIFIER.id COLON type.t SEMI								{: return new TypeFeature(id, t); :}
	;

//////////////////////////////////////////////////////
///////    DECLARATION DES VARIABLES TYPEES    ///////
//////////////////////////////////////////////////////

variable_declaration_part =
	/* empty */ 
	| VAR variable_declaration_list
	;

variable_declaration_list=
	variable_declaration_list.list variable_declaration.name	{: list.add(name); return list; :}
	| variable_declaration.name									{: NodeList list = new NodeList(); list.add(name); return list; :}
	;

variable_declaration =
	identifier_list.list COLON type.t SEMI 
		{: 
		NodeList list_2 = new NodeList();
		Iterator<String> it = list.iterator();
		while(it.hasNext()) {
			String x =  it.next();
			list_2.add(new NodeId(x,t));
			stackEnvironment.putVariable(x,t);
		}
		return list_2; 
		:}
	;
		

identifier_list =
	identifier_list.list COMMA IDENTIFIER.name				{: list.add(name); System.err.println(list.toString()); return list; :}
	| IDENTIFIER.name										{: IdentifierList list = new IdentifierList(); list.add(name); return list; :}
	;

/////////////////////////////////////////////////////////////
//DECLARATION ET DEFINITION DES PROCEDURES ET DES FONCTIONS//
/////////////////////////////////////////////////////////////

procedure_definition_part =
	| procedure_definition_list
	;

procedure_definition_list =
	procedure_definition_list.list procedure_definition.func 			{: list.add(func); return list; :}
	| procedure_definition.func											{: NodeList list = new NodeList(); list.add(func); return list; :}
	;

procedure_definition =
	procedure_definition_head block
	| procedure_definition_head SEMI
	;

procedure_definition_head =
	procedure_head 
	;

procedure_head =
	PROCEDURE IDENTIFIER.func LPAR argt_part.list RPAR					
	{: 
		
		TypeTuple lionel = new TypeTuple();
		Iterator<Node> it = list.iterator();
		while(it.hasNext()) {
			NodeId x = (NodeId) it.next();		
			lionel.add( new TypeFeature(func,x.getType()));
		}

		TypeFunct lionel_le_boss = new TypeFunct(func, lionel, new TypeVoid());
		procedureEnvironment.putFunction(func,lionel_le_boss);

		return new NodeCallFct(func,new TypeFunct(func, lionel, new TypeVoid()), list); 
	:}

	| FUNCTION IDENTIFIER.func LPAR argt_part.list RPAR COLON type.t	
	{: 
		
		TypeTuple lionel = new TypeTuple();
		Iterator<Node> it = list.iterator();
		while(it.hasNext()) {
			NodeId x = (NodeId) it.next();		
			lionel.add( new TypeFeature(func,x.getType()));
		}

		TypeFunct lionel_le_boss = new TypeFunct(func, lionel, t);
		procedureEnvironment.putFunction(func,lionel_le_boss);

		return new NodeCallFct(func,new TypeFunct(func, lionel, t), list); 
	:}
	;

argt_part =
	/* empty */ 
	| argt_list
	;

argt_list =
	argt_list.list COMMA argt.arg			{: list.add(arg); return list; :}
	| argt.arg								{: NodeList list = new NodeList(); list.add(arg); return list; :}
	;

argt =
	IDENTIFIER.name COLON type.t			{: return new NodeId(name, t); :}
	;

////////////////////////////////////////////
///////////////    BLOCS    ////////////////
////////////////////////////////////////////

block=
	push_stack
	variable_declaration_part
	BEGIN
	statement_list.l
	END
	pop_stack
	{:return l;:}
	;

////////////////////////////
////    INSTRUCTIONS    ////
////////////////////////////

statement_list=
	statement_list.list statement.stm		{: list.add(stm); return list; :}
	| statement.stm							{: NodeList list = new NodeList(); list.add(stm); System.out.println(list.toString()); return list; :}
	;

statement=
	simple_statement
	| structured_statement
	;

simple_statement=
	assignment_statement
	| procedure_statement
	| new_statement
	| dispose_statement
	| println_statement
	| readln_statement
	| return_statement
	;

assignment_statement=
	variable_access.stm EQ expression.e SEMI	
	{: 
		
		if(stm.getType()!=null && e.getType()!=null && !stm.getType().equals(e.getType())) {
			semanticError("Type error in affectation", e);
			System.err.println(new String("ERROR  : Type error in affectation " + stm.getType() + "  : " + e.getType()));
			Main.add_error_type(new String("ERROR NodeAssign: Type error in affectation " + stm.getType() + "  : " + e.getType()));
		}
		return new NodeAssign(stm, e);
	:}
	;

procedure_statement=
	procedure_expression.e SEMI {:return e;:}
	;

procedure_expression=
	IDENTIFIER.func LPAR expression_part.list RPAR	
	{: 	
		TypeFunct lionel_le_boss = (TypeFunct)procedureEnvironment.getFunction(func);
		System.out.println("Etape 126 : " + lionel_le_boss);
		System.out.println("Etape 127 : " + list);
		//Case Nb params differents
		if(lionel_le_boss.getParams().size() != list.size()) {
			
			semanticError("Type error in calling expression",list);
			System.err.println("ERROR : Type error in calling expression <NB_PARAM>" + lionel_le_boss + "  : " + list);
			Main.add_error_type(new String("ERROR NodeCallFct : Type error in calling expression <NB_PARAM>" + lionel_le_boss + "  : " + list));
		}
		//Prepare to test the type of parameters
		Iterator<Node> l = list.iterator();
		Iterator <Type> t = lionel_le_boss.getParams().iterator();
		while(l.hasNext() && t.hasNext()) {
			NodeExp n = (NodeExp) l.next();
			TypeFeature m = (TypeFeature) t.next();
			//Type Parameters different
			if(m.get(0)!=null && n.getType()!= null && !n.getType().equals(m.get(0))) {
				semanticError(" Type error in calling expression",list);
				System.err.println("ERROR : Type error in calling expression <BAD TYPES PARAMS>" + lionel_le_boss + "  : " + list);
				Main.add_error_type(new String("ERROR NodeCallFct : Type error in calling expression <BAD TYPES PARAMS>" + lionel_le_boss + "  : " + list));
			}
		}
		
		return new NodeCallFct(func, 
				lionel_le_boss, list);
	:}
	;

expression_part=
	/* empty */ 
	| expression_list					
	;

expression_list=
	expression_list.list COMMA expression.e		{: list.add(e); return list; :}
	| expression.e								{: NodeList list = new NodeList(); list.add(e); return list; :}
	;

new_statement=
	NEW variable_access.stm SEMI		{:return new NodeNew(stm); :}
	;

dispose_statement=
	DISPOSE variable_access.stm SEMI	{: return new NodeDispose(stm); :}
	;

println_statement=		
	PRINTLN expression.e SEMI			
	{: 
		return new NodeCallFct("println",
			new TypeFunct("println",new TypeTuple(new TypeFeature("println",e.getType())),
					new TypeVoid()), new NodeList(e)); 
	:}	
	;
	
readln_statement=
	READLN.func expression.e SEMI		
	{: 
		return new NodeCallFct("readln", 
			new TypeFunct("readln",new TypeTuple(new TypeFeature("readln",e.getType())),
					new TypeVoid()), new NodeList(e)); 
	:}
	;
	
return_statement=
	RETURN expression.e SEMI			{: return new NodeReturn(e); :}
	;
	
structured_statement =
	block													
	| if_statement		
	| while_statement								
	| switch_statement
	
	;

if_statement =
	 IF expression.e THEN statement.stm1 ELSE statement.stm2 	{: return new NodeIf(e, stm1, stm2); :}
	|IF expression.e THEN statement.stm							{: return new NodeIf(e, stm); :}
	;

while_statement=
	WHILE expression.e DO statement.stm 							{: return new NodeWhile(e, stm); :}
	;

switch_statement =
	SWITCH expression.e BEGIN case_statement_list.stm END		{: return new NodeSwitch(e, stm); :}
	;
	
case_statement_list=
	case_statement_list.list case_statement.case1 case_default.case2	{: list.add(case1);if(case2!=null)list.add(case2); return list; :}
	| case_statement.case1 case_default.case2							
	{: 
		NodeCaseList list = new NodeCaseList(); list.add(case1); if(case2!=null)list.add(case2);															
		return list; 
	:}
	;

case_statement=
	CASE identifier_list.list COLON statement.stm			
	{: 
		NodeList list_2 = new NodeList();
		Iterator<String> it = list.iterator();
		while(it.hasNext()) {
			String x =  it.next();
			list_2.add(new NodeCase(x,stm));
		}
		return list_2; 
	:}
	;
	
case_default = 
	/* empty */
	| DEFAULT COLON statement.stm						{: System.out.println("coucou");return new NodeCase(stm); :}
	;

variable_access =
	IDENTIFIER.name											
	{:  
		return new NodeId(name, stackEnvironment.getVariableValue(name));
	:}
	| variable_access.e1 LBRACKET expression.e2 RBRACKET	{: return new NodeArrayAccess(e1, e2) ; :}
	| expression.e CIRCUMFLEX 								{: return new NodePtrAccess(e); :}
	;

///////////////////////////
////    EXPRESSIONS    ////
///////////////////////////

expression =
	expression.e1 PLUS expression.e2  				{: return new NodeOp("+", e1, e2); :}
	| expression.e1 MINUS expression.e2 			{: return new NodeOp("-", e1, e2); :}
	| MINUS expression.e @ UNARY_MINUS 				{: return new NodeOp("-", e); :}
	| expression.e1 TIMES expression.e2 			{: return new NodeOp("*", e1, e2); :}
	| expression.e1 DIV expression.e2 				{: return new NodeOp("/", e1, e2); :}
	| expression.e1 AND expression.e2				{: return new NodeOp("&&", e1, e2); :}
	| expression.e1 OR expression.e2				{: return new NodeOp("||", e1, e2); :}
	| NOT expression.e								{: return new NodeOp("!", e); :}
	| expression.e1 INFERIOR expression.e2			{: return new NodeOp("<", e1, e2); :}
	| expression.e1 INFERIOR_EQ expression.e2		{: return new NodeOp("<=", e1, e2); :}
	| expression.e1 SUPERIOR expression.e2			{: return new NodeOp(">", e1, e2); :}
	| expression.e1 SUPERIOR_EQ expression.e2		{: return new NodeOp(">=", e1, e2); :}
	| expression.e1 EQUALS expression.e2			{: return new NodeOp("==", e1, e2); :}
	| expression.e1 DIFF expression.e2				{: return new NodeOp("!=", e1, e2); :}
	| LPAR expression.e RPAR  						{: return e; :}
	| procedure_expression
	| variable_access
	| literal							
	;

//////////////////////////////////////
////    EXPRESSIONS LITTERALES    ////
//////////////////////////////////////

literal=
	INTEGER_LIT.e	{: return new NodeLiteral(new TypeInt(e), e); :}
	| STRING_LIT.e	{: return new NodeLiteral(new TypeString(), e); :}
	| TRUE			{: return new NodeLiteral(new TypeBoolean(), true); :}
	| FALSE			{: return new NodeLiteral(new TypeBoolean(), false); :}
	| NULL			{: return new NodeLiteral(new TypePointer(), null); :}
	;
