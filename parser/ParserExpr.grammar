%package "ubordeaux.deptinfo.compilation.project.main";
%class "ParserExpr";
%import "ubordeaux.deptinfo.compilation.project.node.*";
%import "ubordeaux.deptinfo.compilation.project.type.*";
%import "ubordeaux.deptinfo.compilation.project.environment.*";
%import "java.util.ArrayList";
%import "java.util.Iterator";


%embed {: 
	static class Events extends beaver.Parser.Events {
		public void syntaxError(Symbol token) {
			System.err.format("*** Erreur de syntaxe en ligne %d, colonne %d. Token inattendu: %s\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()),
				Terminals.NAMES[token.getId()]);
		}
	}
	
	public void semanticError(String msg, Symbol token) {
			System.err.format("*** " + msg + " ligne %d, colonne %d\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()));
		}
		
	private Environment typeEnvironment = new Environment("types");
	private Environment procedureEnvironment = new Environment("procedures");
	private StackEnvironment stackEnvironment = new StackEnvironment("local variables stack");
	private String type_declaration_name;
	
	
:};

%init {: 
	report = new Events();
:};

/////////////////////////////////////////
////////////    TERMINALS    ////////////
/////////////////////////////////////////

%terminals BEGIN, END, TYPE, STR, INT, BOOL, DOUBLE_DOT;
%terminals ARRAY, LBRACKET, RBRACKET, OF, CIRCUMFLEX;
%terminals STRUCT, LCURLY_BRACKET, RCURLY_BRACKET, COLON;
%terminals PROCEDURE, FUNCTION, LPAR, RPAR, VAR;
%terminals NEW, DISPOSE, PRINTLN, READLN, RETURN;
%terminals IF, THEN, ELSE, WHILE;
%terminals DO, SWITCH, CASE, DEFAULT;
%terminals PLUS, MINUS, TIMES, DIV;
%terminals OR, AND, INFERIOR, INFERIOR_EQ, SUPERIOR;
%terminals SUPERIOR_EQ, EQUALS, DIFF, TRUE, FALSE, NULL;
%terminals SEMI, EQ, COMMA, NOT;
%terminals IDENTIFIER, INTEGER_LIT, STRING_LIT;

//////////////////////////
////    LEFT/RIGHT    ////
//////////////////////////

%right UNARY_MINUS, CIRCUMFLEX, NOT, IF, THEN,ELSE;
%left TIMES, DIV, PLUS, MINUS;
%left OR, AND, INFERIOR, INFERIOR_EQ, SUPERIOR, SUPERIOR_EQ, EQUALS, DIFF;

/////////////////////
////   TYPEOF    ////
/////////////////////


////====Node====\\\\

%typeof statement = "Node";
%typeof structured_statement = "Node";
%typeof simple_statement = "Node";
%typeof statement_list = "Node";
%typeof argt = "Node";
%typeof procedure_definition = "NodeCallFct";

////====NodeExp====\\\\

%typeof variable_access = "NodeExp";
%typeof expression = "NodeExp";

////====Integer/String====\\\\

%typeof INTEGER_LIT = "Integer";
%typeof init_enumerated_type = "Integer";
%typeof STRING_LIT = "String";
%typeof IDENTIFIER = "String";

////====Literal====\\\\

%typeof literal = "NodeLiteral";

////====TYPE====\\\\

%typeof type_declaration_part, type = "Type";
%typeof index_type = "Type";
%typeof range_type = "Type";
%typeof subrange_type = "Type";
%typeof variable_declaration_part = "Type";
%typeof variable_declaration_list = "Type";
%typeof feature_type = "TypeFeature";

////====LIST====\\\\

%typeof expression_part = "NodeList";
%typeof expression_list = "NodeList";
%typeof argt_list = "NodeList";
%typeof feature_list_type = "TypeFeatureList";
%typeof case_statement_list = "NodeCaseList";
%typeof identifier_list = "IdentifierList";
%typeof procedure_definition_list = "NodeList";

///////////////////////////////////////
///////////    PROGRAMME    ///////////
///////////////////////////////////////

%goal program;

program =
	type_declaration_part		
	variable_declaration_part		
	procedure_definition_part		
	BEGIN
	statement_list						
	END
	;

////////////////////////////////////////////////
//////    DECLARATION DES TYPES NOMMES    //////
////////////////////////////////////////////////

type_declaration_part =
	/* empty */
	|TYPE type_declaration_list
	;

type_declaration_list =
	type_declaration_list type_declaration
	| type_declaration
	;

type_declaration =
	type_declaration_head EQ type SEMI
	;
	
type_declaration_head =
	IDENTIFIER
	;

////////////////////////////////////////
//////    DEFINITION DES TYPES    //////
////////////////////////////////////////

type=
	simple_type
	| named_type
	| index_type
	| array_type
	| pointer_type
	| structure_type
	;

simple_type =
	STR						{: return new TypeString(); :}
	| INT					{: return new TypeInt(); :}
	| BOOL					{: return new TypeBoolean(); :}
	;

named_type =
	IDENTIFIER.name			{: return new NodeId(name, new TypeInt()); :}
	;

index_type =
	enumerated_type
	| subrange_type
	;

enumerated_type =
	init_enumerated_type LPAR identifier_list.t_list RPAR
		{: return new TypeEnumRange(new TypeItemEnum(0,t_list.first()),new TypeItemEnum(t_list.size()-1,t_list.last())); :}
	;
	
init_enumerated_type = 
							{:	return new TypeEnumRange();	:}
	;

subrange_type =
	INTEGER_LIT.min DOUBLE_DOT INTEGER_LIT.max				{: return new TypeArrayRange(new TypeInt(min), new TypeInt(max)); :}
	| IDENTIFIER.min DOUBLE_DOT IDENTIFIER.max				{: return new TypeArrayRange(new TypeNamed(min), new TypeNamed(max)); :}
	;

array_type =
	ARRAY LBRACKET range_type.t1 RBRACKET OF type.t2			{: return new TypeArray(t1,t2); :}
	;

range_type =
	enumerated_type
	| subrange_type
	| named_type
	;

pointer_type =
	CIRCUMFLEX type.t											{: return new TypePointer(t); :}
	;

structure_type =
	STRUCT LCURLY_BRACKET feature_list_type.t RCURLY_BRACKET	{: return new TypeStruct(t); :}
	;

feature_list_type =
	feature_list_type.list feature_type.t						{: list.add(t); return list; :}
	| feature_type.t											{: TypeFeatureList list = new TypeFeatureList(); list.add(t); return list; :}
	;

feature_type =
	IDENTIFIER.id COLON type.t SEMI								{: return new TypeFeature(id, t); :}
	;

//////////////////////////////////////////////////////
///////    DECLARATION DES VARIABLES TYPEES    ///////
//////////////////////////////////////////////////////

variable_declaration_part =
	/* empty */ 
	| VAR variable_declaration_list
	;

variable_declaration_list=
	variable_declaration_list.list variable_declaration		{: return new TypeList(list); :}
	| variable_declaration							
	;

variable_declaration =
	identifier_list COLON type SEMI
	;

identifier_list =
	identifier_list.list COMMA IDENTIFIER.name				{: list.add(name); return list; :}
	| IDENTIFIER.name										{: IdentifierList list = new IdentifierList(); list.add(name); return list; :}
	;

/////////////////////////////////////////////////////////////
//DECLARATION ET DEFINITION DES PROCEDURES ET DES FONCTIONS//
/////////////////////////////////////////////////////////////

procedure_definition_part =
	| procedure_definition_list
	;

procedure_definition_list =
	procedure_definition_list.list procedure_definition.func 			{: list.add(func); return list; :}
	| procedure_definition.func											{: NodeList list = new NodeList(); list.add(func); return list; :}
	;

procedure_definition =
	procedure_definition_head block
	| procedure_definition_head SEMI
	;

procedure_definition_head =
	procedure_head 
	;

procedure_head =
	PROCEDURE IDENTIFIER.func LPAR argt_part.list RPAR					{: return new NodeCallFct(func, new TypeFunct(func,new TypeTuple(), new TypeVoid()), list); :}
	| FUNCTION IDENTIFIER.func LPAR argt_part.list RPAR COLON type.t	{: return new NodeCallFct(func, new TypeFunct(func,new TypeTuple(), t), list); :}
	;

argt_part =
	/* empty */ 
	| argt_list
	;

argt_list =
	argt_list.list COMMA argt.arg			{: list.add(arg); return list; :}
	| argt.arg								{: NodeList list = new NodeList(); list.add(arg); return list; :}
	;

argt =
	IDENTIFIER.name COLON type.t			{: return new NodeId(name, t); :}
	;

////////////////////////////////////////////
///////////////    BLOCS    ////////////////
////////////////////////////////////////////

block=
	variable_declaration_part
	BEGIN
	statement_list
	END
	;

////////////////////////////
////    INSTRUCTIONS    ////
////////////////////////////

statement_list=
	statement_list.list statement.stm		{: list.add(stm); return list; :}
	| statement.stm							{: NodeList list = new NodeList(); list.add(stm); return list; :}
	;

statement=
	simple_statement
	| structured_statement
	;

simple_statement=
	assignment_statement
	| procedure_statement
	| new_statement
	| dispose_statement
	| println_statement
	| readln_statement
	| return_statement
	;

assignment_statement=
	variable_access.stm EQ expression.e SEMI	{: return new NodeAssign(stm, e); :}
	;

procedure_statement=
	procedure_expression SEMI
	;

procedure_expression=
	IDENTIFIER.func LPAR expression_part.list RPAR	{: return new NodeCallFct(func, new TypeFunct(func,new TypeTuple(), new TypeVoid()), list); :}
	;

expression_part=
	/* empty */ 
	| expression_list					
	;

expression_list=
	expression_list.list COMMA expression.e		{: list.add(e); return list; :}
	| expression.e								{: NodeList list = new NodeList(); list.add(e); return list; :}
	;

new_statement=
	NEW variable_access.stm SEMI		{: return new NodeNew(stm); :}
	;

dispose_statement=
	DISPOSE variable_access.stm SEMI	{: return new NodeDispose(stm); :}
	;

println_statement=		
	PRINTLN expression.e SEMI			{: return new NodeCallFct("println", new TypeFunct("println",new TypeTuple(), new TypeVoid()), new NodeList(e)); :}	
	;
	
readln_statement=
	READLN.func expression.e SEMI		{: return new NodeCallFct("readln", new TypeFunct("readln",new TypeTuple(), new TypeVoid()), new NodeList(e)); :}
	;
	
return_statement=
	RETURN expression.e SEMI			{: return new NodeReturn(e); :}
	;
	
structured_statement =
	block.block													
	| if_statement		
	| while_statement								
	| switch_statement								
	;

if_statement =
	 IF expression.e THEN statement.stm1 ELSE statement.stm2 	{: return new NodeIf(e, stm1, stm2); :}
	|IF expression.e THEN statement.stm							{: return new NodeIf(e, stm); :}
	;

while_statement=
	WHILE expression.e DO statement.stm							{: return new NodeWhile(e, stm); :}
	;

switch_statement =
	SWITCH expression.e BEGIN case_statement_list.stm END		{: return new NodeSwitch(e, stm); :}
	;
	
case_statement_list=
	case_statement_list.list case_statement.case1 case_default.case2	//{: list.add(case2); list.add(case1); return list; :}
	| case_statement.case												//{: NodeCaseList list = new NodeCaseList(); list.add(case); return list; :}
	;

case_statement=
	CASE identifier_list COLON statement.stm			{: return new NodeCase(stm); :}
	;
	
case_default = 
	/* empty */
	| DEFAULT COLON statement.stm						{: return new NodeCase(stm); :}
	;

variable_access =
	IDENTIFIER.name										{: return new NodeId(name, new TypeInt()); :}
	| variable_access.e LBRACKET expression RBRACKET	{: return e; :}
	| expression.e CIRCUMFLEX 							{: return new NodePtrAccess(e); :}
	;

///////////////////////////
////    EXPRESSIONS    ////
///////////////////////////

expression =
	expression.e1 PLUS expression.e2  				{: return new NodeOp("+", e1, e2); :}
	| expression.e1 MINUS expression.e2 			{: return new NodeOp("-", e1, e2); :}
	| MINUS expression.e @ UNARY_MINUS 				{: return new NodeOp("-", e); :}
	| expression.e1 TIMES expression.e2 			{: return new NodeOp("*", e1, e2); :}
	| expression.e1 DIV expression.e2 				{: return new NodeOp("/", e1, e2); :}
	| expression.e1 AND expression.e2				{: return new NodeOp("&&", e1, e2); :}
	| expression.e1 OR expression.e2				{: return new NodeOp("||", e1, e2); :}
	| NOT expression.e								{: return new NodeOp("!", e); :}
	| expression.e1 INFERIOR expression.e2			{: return new NodeOp("<", e1, e2); :}
	| expression.e1 INFERIOR_EQ expression.e2		{: return new NodeOp("<=", e1, e2); :}
	| expression.e1 SUPERIOR expression.e2			{: return new NodeOp(">", e1, e2); :}
	| expression.e1 SUPERIOR_EQ expression.e2		{: return new NodeOp(">=", e1, e2); :}
	| expression.e1 EQUALS expression.e2			{: return new NodeOp("==", e1, e2); :}
	| expression.e1 DIFF expression.e2				{: return new NodeOp("!=", e1, e2); :}
	| LPAR expression.e RPAR  						{: return e; :}
	| procedure_expression
	| variable_access
	| literal							
	;

//////////////////////////////////////
////    EXPRESSIONS LITTERALES    ////
//////////////////////////////////////

literal=
	INTEGER_LIT.e	{: return new NodeLiteral(new TypeInt(), e); :}
	| STRING_LIT.e	{: return new NodeLiteral(new TypeString(), e); :}
	| TRUE			{: return new NodeLiteral(new TypeBoolean(), true); :}
	| FALSE			{: return new NodeLiteral(new TypeBoolean(), false); :}
	| NULL			{: return new NodeLiteral(new TypePointer(), null); :}
	;
