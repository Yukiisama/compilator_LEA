package ubordeaux.deptinfo.compilation.project.main;

import java.util.Iterator;
import ubordeaux.deptinfo.compilation.project.environment.*;
import ubordeaux.deptinfo.compilation.project.type.*;
import beaver.*;
import java.util.ArrayList;
import ubordeaux.deptinfo.compilation.project.node.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "ParserExpr.grammar".
 */
public class ParserExpr extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjM6bu55KMFTLTYAAue7OI76HLI005OKGWW14m8W4HY2mY2OGb4713HN6TSOcAeYOYAgw" +
		"i8ku6b4LGL52388YEpgYupI8pEkxCk70zLNsx#YNTNIdxCnz$x7otxdttdNVFs#gzMm7iFH" +
		"YA20QX3uhG14zYFpJ2$ZW0ZN4W3iB1E0I7uZ0SZXFH1TsGZp$Y50p0gHY845v35VR14wY6Z" +
		"KpqH0$qaPja9vx2J9oB4ap7QHY6Cp0AOp0bIOI6wNAJOoKvnk4FKLOSgUmxwPs9S03kyRWN" +
		"L#96pCPbk09NuK$uCwv6BYFSnGWP2H7CdkxxAsOfndARmN8Uvf6d0NaU#SrvAWsUIqN8yo1" +
		"vclhoJ4g3Pxx1ynYQAa#kBqzf6Zml63nFeueyUUGPxCipBGsULmsU8gmWJr$o5FloN9G6pn" +
		"i6p#lOGfx9TUw3nrFoD4CBVGEQeZbQwlC8jCPHQ8jij4T778lEn6NXV1GezW8Vt0nSYExix" +
		"SDu2CjIuXB7jv1$SzY#7qv2A#NfxSCp4cqKTJckzy6TYQCLTmDkzi6DHJl5tOAvFhWSFIdU" +
		"mQryqrFXelvcwA0nNyGpc9WIVGvc4NkCOk$49IZpwK4dnTsDUt2V3#uunIt4$LZWW#kgk2L" +
		"OBF$qmHqVYoV$mAC#k1DqXlwEPx7A1zTBuwt1UgppmPsikEVn4bxsmGt541Ut2QzWkozkk8" +
		"lRZgtOveCReUFuFvnVQjnexHzySOaxFj5pLZoIh0tKudVFtlAKSut#ZKLOwbaLDQmxF6k3M" +
		"XDqTIkm6ckvn3VXTbo3Qt5TOAiSwvrOyXUKongDEjMBUhPQCSR#c2LlaCSvUpQISJbEJnhr" +
		"Oho9BIZ40tmFSsKhuh$DC7#vlA6TttCn1wDt9sDFrlJYMTs7ivJ7qxilp$3#V6lplRcocEk" +
		"5cUCrOBRNqCrAnlEyBU8PFegdHOaNPJhlhAdC12VmBJg2kLapvcNDUKErJ1AXVThS4MPdcU" +
		"IEjO$f2BsPZ1Q4ku1tws3UjqCufqDvwmxd$BLZ18iHEYH4IBUdoLZQSoT6tBvsgbUUjbpW2" +
		"6#xJ6OEzSlJI7dQrIkFizyYn6LozUkJnuaHORQKoMTzyencPXFXUPJ#FWXvk6XkM3j3RA8v" +
		"OeWpDih3TlF1JUHgPdczJOLB79$5lydqbZ7pZl5a#$OdXihWtHe4Pt5t1S5bCsjAZOkV59q" +
		"PCHKkwe#ZEpApwveI7M767iUEOGvmV80Uj6MVmm5m5gEdxcaSPtCU$MOy7Y#R4Ul6PHCPf7" +
		"zPn8q8DDwWyTe66g$5KpeZ0Au3lu2bRfo8BoxPZg$jCIAvir9tYzyzUyt3DN8yOpohaMcXr" +
		"BD6g1K$QOinZiXM$3vemo#4emDRbli6s6wEaPKGDRwleumvV4kpoEESFMJagPAHDEeKznx9" +
		"S7TSEwT5x8T9OlnOb#Fg7C#JnVnWnrLE5YZo6TLfG6WYzHBAUPGcb2#S#dI4lx6KBe3rNjm" +
		"N8gVrBX2UJvkky78w$qLTHNycDJFJ47FKy4Rg5TJCPKElKhz3$JxrHzHVKU#YDA1yGs7Cy4" +
		"#KZe3T8CfZ7yXo7dK6utvfz6aFVIqOmuxxh49YAwXdQDi5b6pw2fEFApo5sBwAFOwoJlsNq" +
		"#v9sQnr$SZJHkr1j4zG#mpQ1SfzCH#BAKEqheXrnJGuHzPiIcFrbz9$0SjvMkRwX9nwzXjp" +
		"DDO6rPmZwqATxrQKrZfspgazY#Niu6iOuXu83QlbS#Pv4pM$SaC3QL#fVRf6wxjHBgDHRhI" +
		"Po$eRg9TeUGs5QsjNQtcRWLr9#T0eEtk2Nq6XJxIycuyVECPbDVjbBzHnzelxmWTGzcUTiv" +
		"SQAcuBxHPQtvZbEGQ#AuLxrlwK#bWAvy#kCke7KCvKkpFhLb7dQzdZvVkqcigvUTPhcVE5q" +
		"K7ct4yOPrVDCUCerTbHRUdyHlSyvogiEaDrUzMzLHUgBbEjQncgLBrKzHhLMsltAROkDNtM" +
		"sbgOtK76vwnLhN9pm#vYsFc6FQrc6vxotZjXwrf1tmryh$xhj9yvMfxjwEWwMVErRe4ndh6" +
		"AcnbxTpLUfo3ZgdlSrZeZPedgUN6VtTharVhgckNGfUbnXnPf7ofgnT#j$eB4DdRtMZ6gZN" +
		"QI17##CLPZ7UrobakCkic9RR638VV8JdW$UKrUaKsoKLwMb#H5sI0loFFoj3mbJyeJKkaYr" +
		"iiYFXTIU9hB0vJxAVTHxgNmzf6xANTHxgJCezn1uSqZzxZjvyhj6ccnLCWIrtB$QoAhvJQv" +
		"LMwHENAph29g7NsLygnRLodFk7gb#rpXFgkqpzMg7wSyflQZteWUaOTakMijfNmWxwl$R$8" +
		"$sItVotVohNmZNyjNygNyb$xFv0lvt9WHtg7ogTgVoCTgVQZwFvI$ohkklKi#KkzxgfV9my" +
		"8xLjwcx90tlPZRtUSMzxbPNeVnasto5fy$oqzQvdaiFzAOWUdCiSRJ6i#SQv8h5ZCKcpcAn" +
		"Q$Vv7Aw8OCeGrK6irq1dCmaxCemnfxiVcb6PJZZ5n9JIbtAyXZQlOZlnV8KLopcJJOpgR3x" +
		"5LN2kXBggQoRIZsMsf4YdXb5p0oBMLzC$pZYnsacrfljHn8pakK#AYVwo4d4zoM#9$Kqnfj" +
		"6NndZb57te#vFEPcIJpc5aaU$AGFORW37UIhrGFPh0Z4Jw1$5ifETJMIv1yizMExXVh#4LK" +
		"pRpsUAvKbk4Zdx5$uOAcK=");

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN6 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 6];
		}
	};

	static final Action RETURN7 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 7];
		}
	};
 
	static class Events extends beaver.Parser.Events {
		public void syntaxError(Symbol token) {
			System.err.format("*** Erreur de syntaxe en ligne %d, colonne %d. Token inattendu: %s\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()),
				Terminals.NAMES[token.getId()]);
		}
	}
	
	public void semanticError(String msg, Symbol token) {
			System.err.format("*** " + msg + " ligne %d, colonne %d\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()));
		}
		
	private Environment typeEnvironment = new Environment("types");
	private Environment procedureEnvironment = new Environment("procedures");
	private StackEnvironment stackEnvironment = new StackEnvironment("local variables stack");
	private String type_declaration_name;

	private final Action[] actions;

	public ParserExpr() {
		super(PARSING_TABLES);
		actions = new Action[] {
			RETURN5,	// [0] program = type_declaration_part variable_declaration_part procedure_definition_part BEGIN statement_list.stm END
			Action.NONE,  	// [1] type_declaration_part = 
			RETURN2,	// [2] type_declaration_part = TYPE type_declaration_list; returns 'type_declaration_list' although none is marked
			new Action() {	// [3] type_declaration_list = type_declaration_list type_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [4] type_declaration_list = type_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN4,	// [5] type_declaration = type_declaration_head EQ type SEMI; returns 'SEMI' although none is marked
			Action.RETURN,	// [6] type_declaration_head = IDENTIFIER
			Action.RETURN,	// [7] type = simple_type
			Action.RETURN,	// [8] type = named_type
			Action.RETURN,	// [9] type = index_type
			Action.RETURN,	// [10] type = array_type
			Action.RETURN,	// [11] type = pointer_type
			Action.RETURN,	// [12] type = structure_type
			Action.RETURN,	// [13] simple_type = STR
			Action.RETURN,	// [14] simple_type = INT
			Action.RETURN,	// [15] simple_type = BOOL
			Action.RETURN,	// [16] named_type = IDENTIFIER
			Action.RETURN,	// [17] index_type = enumerated_type
			Action.RETURN,	// [18] index_type = subrange_type
			RETURN4,	// [19] enumerated_type = init_enumerated_type LPAR identifier_list RPAR; returns 'RPAR' although none is marked
			Action.NONE,  	// [20] init_enumerated_type = 
			RETURN3,	// [21] subrange_type = INTEGER_LIT DOUBLE_DOT INTEGER_LIT; returns 'INTEGER_LIT' although none is marked
			RETURN3,	// [22] subrange_type = IDENTIFIER DOUBLE_DOT IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN6,	// [23] array_type = ARRAY LBRACKET range_type RBRACKET OF type; returns 'type' although none is marked
			Action.RETURN,	// [24] range_type = enumerated_type
			Action.RETURN,	// [25] range_type = subrange_type
			Action.RETURN,	// [26] range_type = named_type
			RETURN2,	// [27] pointer_type = CIRCUMFLEX type; returns 'type' although none is marked
			RETURN4,	// [28] structure_type = STRUCT LCURLY_BRACKET feature_list_type RCURLY_BRACKET; returns 'RCURLY_BRACKET' although none is marked
			new Action() {	// [29] feature_list_type = feature_list_type feature_type
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [30] feature_list_type = feature_type
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN4,	// [31] feature_type = IDENTIFIER COLON type SEMI; returns 'SEMI' although none is marked
			Action.NONE,  	// [32] variable_declaration_part = 
			RETURN2,	// [33] variable_declaration_part = VAR variable_declaration_list; returns 'variable_declaration_list' although none is marked
			new Action() {	// [34] variable_declaration_list = variable_declaration_list variable_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [35] variable_declaration_list = variable_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN4,	// [36] variable_declaration = identifier_list COLON type SEMI; returns 'SEMI' although none is marked
			new Action() {	// [37] identifier_list = identifier_list COMMA IDENTIFIER
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [38] identifier_list = IDENTIFIER
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			Action.NONE,  	// [39] procedure_definition_part = 
			Action.RETURN,	// [40] procedure_definition_part = procedure_definition_list
			new Action() {	// [41] procedure_definition_list = procedure_definition_list procedure_definition
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [42] procedure_definition_list = procedure_definition
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN2,	// [43] procedure_definition = procedure_definition_head block; returns 'block' although none is marked
			RETURN2,	// [44] procedure_definition = procedure_definition_head SEMI; returns 'SEMI' although none is marked
			RETURN5,	// [45] procedure_definition_head = PROCEDURE IDENTIFIER LPAR argt_part RPAR; returns 'RPAR' although none is marked
			RETURN7,	// [46] procedure_definition_head = FUNCTION IDENTIFIER LPAR argt_part RPAR COLON type; returns 'type' although none is marked
			Action.NONE,  	// [47] argt_part = 
			Action.RETURN,	// [48] argt_part = argt_list
			new Action() {	// [49] argt_list = argt_list COMMA argt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [50] argt_list = argt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN3,	// [51] argt = IDENTIFIER COLON type; returns 'type' although none is marked
			RETURN4,	// [52] block = variable_declaration_part BEGIN statement_list END; returns 'END' although none is marked
			new Action() {	// [53] statement_list = statement_list statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [54] statement_list = statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [55] statement = simple_statement
			Action.RETURN,	// [56] statement = structured_statement
			Action.RETURN,	// [57] simple_statement = assignment_statement
			Action.RETURN,	// [58] simple_statement = procedure_statement
			Action.RETURN,	// [59] simple_statement = new_statement
			Action.RETURN,	// [60] simple_statement = dispose_statement
			Action.RETURN,	// [61] simple_statement = println_statement
			Action.RETURN,	// [62] simple_statement = readln_statement
			Action.RETURN,	// [63] simple_statement = return_statement
			RETURN4,	// [64] assignment_statement = variable_access EQ expression SEMI; returns 'SEMI' although none is marked
			RETURN2,	// [65] procedure_statement = procedure_expression SEMI; returns 'SEMI' although none is marked
			RETURN4,	// [66] procedure_expression = IDENTIFIER LPAR expression_part RPAR; returns 'RPAR' although none is marked
			Action.NONE,  	// [67] expression_part = 
			Action.RETURN,	// [68] expression_part = expression_list
			new Action() {	// [69] expression_list = expression_list COMMA expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [70] expression_list = expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN3,	// [71] new_statement = NEW variable_access SEMI; returns 'SEMI' although none is marked
			RETURN3,	// [72] dispose_statement = DISPOSE variable_access SEMI; returns 'SEMI' although none is marked
			RETURN3,	// [73] println_statement = PRINTLN expression SEMI; returns 'SEMI' although none is marked
			RETURN3,	// [74] readln_statement = READLN expression SEMI; returns 'SEMI' although none is marked
			RETURN3,	// [75] return_statement = RETURN expression SEMI; returns 'SEMI' although none is marked
			Action.RETURN,	// [76] structured_statement = block
			Action.RETURN,	// [77] structured_statement = if_statement
			Action.RETURN,	// [78] structured_statement = while_statement
			Action.RETURN,	// [79] structured_statement = switch_statement
			RETURN4,	// [80] if_statement = IF expression THEN statement; returns 'statement' although none is marked
			RETURN6,	// [81] if_statement = IF expression THEN statement ELSE statement; returns 'statement' although none is marked
			RETURN4,	// [82] while_statement = WHILE expression DO statement; returns 'statement' although none is marked
			RETURN5,	// [83] switch_statement = SWITCH expression BEGIN case_statement_list END; returns 'END' although none is marked
			RETURN3,	// [84] case_statement_list = case_statement_list case_statement case_default; returns 'case_default' although none is marked
			Action.RETURN,	// [85] case_statement_list = case_statement
			RETURN4,	// [86] case_statement = CASE identifier_list COLON statement; returns 'statement' although none is marked
			Action.NONE,  	// [87] case_default = 
			RETURN3,	// [88] case_default = DEFAULT COLON statement; returns 'statement' although none is marked
			Action.RETURN,	// [89] variable_access = IDENTIFIER
			RETURN4,	// [90] variable_access = variable_access LBRACKET expression RBRACKET; returns 'RBRACKET' although none is marked
			RETURN2,	// [91] variable_access = expression CIRCUMFLEX; returns 'CIRCUMFLEX' although none is marked
			RETURN3,	// [92] expression = expression.e1 PLUS expression.e2; returns 'e2' although more are marked
			RETURN3,	// [93] expression = expression.e1 MINUS expression.e2; returns 'e2' although more are marked
			RETURN2,	// [94] expression = MINUS expression.e
			RETURN3,	// [95] expression = expression.e1 TIMES expression.e2; returns 'e2' although more are marked
			RETURN3,	// [96] expression = expression.e1 DIV expression.e2; returns 'e2' although more are marked
			RETURN3,	// [97] expression = expression.e1 AND expression.e2; returns 'e2' although more are marked
			RETURN3,	// [98] expression = expression.e1 OR expression.e2; returns 'e2' although more are marked
			RETURN2,	// [99] expression = NOT expression.e
			RETURN3,	// [100] expression = expression.e1 INFERIOR expression.e2; returns 'e2' although more are marked
			RETURN3,	// [101] expression = expression.e1 INFERIOR_EQ expression.e2; returns 'e2' although more are marked
			RETURN3,	// [102] expression = expression.e1 SUPERIOR expression.e2; returns 'e2' although more are marked
			RETURN3,	// [103] expression = expression.e1 SUPERIOR_EQ expression.e2; returns 'e2' although more are marked
			RETURN3,	// [104] expression = expression.e1 EQUALS expression.e2; returns 'e2' although more are marked
			RETURN3,	// [105] expression = expression.e1 DIFF expression.e2; returns 'e2' although more are marked
			new Action() {	// [106] expression = LPAR expression.e RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e = _symbols[offset + 2];
					 return e;
				}
			},
			Action.RETURN,	// [107] expression = procedure_expression
			Action.RETURN,	// [108] expression = variable_access
			Action.RETURN,	// [109] expression = literal
			Action.RETURN,	// [110] literal = INTEGER_LIT
			Action.RETURN,	// [111] literal = STRING_LIT
			Action.RETURN,	// [112] literal = TRUE
			Action.RETURN,	// [113] literal = FALSE
			Action.RETURN	// [114] literal = NULL
		};

 
	report = new Events();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
