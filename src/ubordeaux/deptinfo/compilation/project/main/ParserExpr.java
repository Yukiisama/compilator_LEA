package ubordeaux.deptinfo.compilation.project.main;

import java.util.Iterator;
import ubordeaux.deptinfo.compilation.project.environment.*;
import ubordeaux.deptinfo.compilation.project.type.*;
import beaver.*;
import java.util.ArrayList;
import ubordeaux.deptinfo.compilation.project.main.*;
import ubordeaux.deptinfo.compilation.project.node.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "ParserExpr.grammar".
 */
public class ParserExpr extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjLtTy5LKM$gP4CAiiDhAi8cyL3O4OObnHYH1w5KGaI4T1bo8bObaK51j2C4O46og26ff" +
		"qH10h8gA8W0KH55XTLsNPrMNj1Jr#CpapRv8txpa1$$6dx$s##SuzzznpRfixvmBsAXIYDh" +
		"gY9Ix1CPY4F#0m78uQ#2DguWWSYQDmD6eX0t$24jo11p03fPY2gPY6Et4NspoBjr2joZuU2" +
		"VXu6zjXOKW57#afV1o8tSY8TaKHxQw8Q7TTHBkRKzYrGcCqGKUSYKuu1vtH9KHpBfgXANqL" +
		"ur9SYMxeWLxeYm4OYCj2D3QgopQknMgimXFOW4ru7aEZn95DE0Jjq0Qp8iM9qlDZotikF$n" +
		"Y7klgN1nwW1vVHPsGaQ$2EgmFQH#J9$0NZRW1xTdsU9o0UZWPzT40sSX1BlBmLno764xKiG" +
		"hgS2QJMSPmDavIZoOM9BNptgNPWNUfZhp5zfdQsbdN5adRzw5bblPe8kPZULBB$hHig3vlO" +
		"8nNarfUHCjJrF8bMjL9QdanBHkfPG5QetkA#JZLj$iRsgQmEqtjOZWFWtsx4KbR9AxzvMnx" +
		"kdePXb7uUufePwZTU5o3dYdipl9xFmvZVtOr5mLMqzDj3D6z6Q9x9w2BygRyhlbrQQRZQla" +
		"t7iDAIkDTgOnIYI$DywLRLShNlLU6Qp413s8ExiOzk3UoD1tNkvvkf3HHVSQm5SzmBvTX3U" +
		"KqVqVVZgTykRd63VCPmzDiNq1UmxFsptuRZsEu2Q$nh8tnh9d0Vs9z1$L#7#x7J5zVYFDTR" +
		"I4kSBctMlLJlb1vaF9mvT7ALocNOBhiSiUwYvd9BRWD3#59FCpU56Ckp#D7iGqBiHXZi1IJ" +
		"sRzbM24Vud7vbto0vx0MB#15VWbUnYlOZ2ru7MzW9$yx0FaQxt95ytc#DsMi0ivI2yPhnTE" +
		"l3S#rTlnwTE1wnx$fNNcETUEekdDCFJWgfyrPFBSFniS0piEGAlZuhTaP$EPQp93IcEbKGt" +
		"Lc4OaQprSUixFQtC77yklkxCAwt9k9cjxyTcRwQs7m#vX3JPGu6MnNn1nZUAGuLUavVd6FV" +
		"G$GOo$cy64ZluJV#iJs9ckyY0Q$d#7v$p7CdCt0MDFPAfbbq6Cp#anc5$OkfNDzud6STSsA" +
		"rAFHp36IzoXesI1btojRfaUohC#vhfLYFk9slLFEcsTdqbkcRzSuQOl4LJupuAKlywdC2D5" +
		"oUPv7w$sfp5khife7euloflok#RLf6hgQYoZbkf9pKlNqfH6#D50bR##bCxitU2iyWJU#Uh" +
		"pBHPKyxmR$$TMdoNpbOkxbTDveJDxIlHrTYxSJJ$RYXlaiRr#VF9XdRRRVncEJVNNEMfCdY" +
		"14u$#BrdlT6hAsV4FDWkIUzPhfZTJAJVknD5kVpDFR6kHKPdFrBgQl5svY5aUuCDQA5JMHH" +
		"Qr2RmMSlTyOT#MHt5DcyOsUp7jXzFHyEHEHZqWfYAx4FC2po5d8hOhLdTo00xAC0Snpzp8Z" +
		"hpBqiZoT$JbvAta$U2LXfb6kG2NCWEOFjsLShHZwEd4LkJCuZDo7dazkIMvCxaZkJUv09yq" +
		"Jo078zyX3wNnw8NvkwowXR7z0Li5nCRbvUDjXdwngM9uIFovnET2#NhPiedwBwHIoNa4kqx" +
		"Yxw#aZb1ob$h$9SsjHKsPc3atI#1b7cU8p3MDWUZsUjffvZDhB979znkkhNijo5vK8jRsHv" +
		"C554UO7swMQjsqIx$YfpxctEaNs4ZlUwGAozWVLpvhIBoiDOnprYrqYrvXNdoSuX#bNIdK5" +
		"C8hWkzeNqkKFZxjPwhhrzD$kqET3c2jP$G9wWvVi8Ppu$qV9eOcR0$cfYB35EnxT6zLCgzM" +
		"KECPk2aAVgV9cKvslzBOox9s2$a5X0VsNaUud9nE61UgwblKpbYSIHn2mj5yVjZ2byxzwXC" +
		"9F#LpewbjV3oSbWr8mwlwddtaYhLCvH7gmyrkkByXBbTSgwBiQdEY#MSePoGsNT7#P0vQlA" +
		"sLgHs2ThNw8EyogMxRhHncStg5JE2SXv0RbnG6uIa9l5PME$mro3FQJZEOPSjMcfVSnJRgj" +
		"wPVJMSaSlhlF#bijcpy0OH#huLrKQ#urnkNmVg9zSbYTvPMTl99k7ge2$nG6VUtJifO4#Z7" +
		"7Upufjp2ihbktsqUDPspJMU#7rHgDAlhi5ueuFyVTXe3xmFjavZF5#e6vQoDXtioS$odxPv" +
		"HGe$UZoI$AYh9CNPAqyBslaENbMdf6dPR4iaeMoG4fTcwU4xwdml94PnFq4pn$XDq1u1WZF" +
		"Ak4vBtSIquYfn1t40yGzRlifShjwcYMtoKEkjDfzhfGIkLKcIx5CaiTfzIHrfRB2hIkLnrn" +
		"UxZwNkS#bxdE9DmBvGLvMUJxngChpe3#PAu$875Vti6gsKowJjwcVxPmuibFUrPeTyfLyAL" +
		"$8v$AP$5$soV$aK$c4#e$bl$8V#3$vYFYdok$BUohjLjxhFlV8FxJCKqwsCkORyhgyvllOu" +
		"ZutkiyDyWe2FzaiR$BvlNodvM#8RocCuGsnEc#ZuAq86EB2P1xam62UP3DJCdZ$2CVv0PnB" +
		"T5TqPJj#GNbpiLmKCjCTJhs77lH$0Mr6a4UucPVD6o3VV9P7kd0oNTlDKPsiRIZhXf97iMu" +
		"KUP2RQvhCDWtcccb4DMQM80pcbnRXv6aM2XYt3#twiDnSqU9dq8fnMxFDsMHcD8I18leg8h" +
		"SXjoNQ4Us93aH7eYNhWkZ4k9tO$XoYC$ldP9J3wBCVo$tfqycuyscNptA#c$TQYg2SIXU4u" +
		"QDf22x$2LsT9dm=");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};
 
	static class Events extends beaver.Parser.Events {
		public void syntaxError(Symbol token) {
			System.err.format("*** Erreur de syntaxe en ligne %d, colonne %d. Token inattendu: %s\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()),
				Terminals.NAMES[token.getId()]);
		}
	}
	
	public void semanticError(String msg, Symbol token) {
			System.err.format("*** " + msg + " ligne %d, colonne %d\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()));
		}
		
	private Environment typeEnvironment = new Environment("types");
	private Environment procedureEnvironment = new Environment("procedures");
	private StackEnvironment stackEnvironment = new StackEnvironment("local variables stack");
	private String type_declaration_name;

	private final Action[] actions;

	public ParserExpr() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] program = push_stack type_declaration_part variable_declaration_part procedure_definition_part BEGIN statement_list.l END pop_stack
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 6];
					final Node l = (Node) _symbol_l.value;
					 return l;
				}
			},
			new Action() {	// [1] push_stack = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 stackEnvironment.push_stack(); return new Symbol(0);
				}
			},
			new Action() {	// [2] pop_stack = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 stackEnvironment.pop_stack();  return new Symbol(0);
				}
			},
			Action.NONE,  	// [3] type_declaration_part = 
			RETURN2,	// [4] type_declaration_part = TYPE type_declaration_list; returns 'type_declaration_list' although none is marked
			new Action() {	// [5] type_declaration_list = type_declaration_list.list type_declaration.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final TypeList list = (TypeList) _symbol_list.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Type t = (Type) _symbol_t.value;
					 list.add(t); return list;
				}
			},
			new Action() {	// [6] type_declaration_list = type_declaration.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					 TypeList list = new TypeList(t);  return list;
				}
			},
			new Action() {	// [7] type_declaration = type_declaration_head.name EQ type.t SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final TypeNamed name = (TypeNamed) _symbol_name.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					
		if(!t.equals(new TypeInt()) && !t.equals(new TypeBoolean()) 
				&& !t.equals(new TypeString())) {
				if(t instanceof TypeNamed) {
					if(typeEnvironment.getVariableValue(((TypeNamed)t).get_name())==null) {
						semanticError("Error : Named type assigned doesn't exist " + name + ": " + t,t);
						System.err.println("ERROR :Named type assigned doesn't exist  " + name + ": " + t);
						Main.add_error_type(new String("ERROR Type declaration : Named type assigned doesn't exist  "+ name + ": " + t ));
					}
				}
		}
		typeEnvironment.putVariable(name.get_name(),t);
		System.out.println("PARLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + t);
		//typeEnvironment.putEnumToName((TypeEnumRange) t,name.get_name());
		return new TypeFeature(name.get_name(),t);
				}
			},
			new Action() {	// [8] type_declaration_head = IDENTIFIER.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					 return new TypeNamed(name);
				}
			},
			Action.RETURN,	// [9] type = simple_type
			Action.RETURN,	// [10] type = named_type
			Action.RETURN,	// [11] type = index_type
			Action.RETURN,	// [12] type = array_type
			Action.RETURN,	// [13] type = pointer_type
			Action.RETURN,	// [14] type = structure_type
			new Action() {	// [15] simple_type = STR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeString();
				}
			},
			new Action() {	// [16] simple_type = INT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeInt();
				}
			},
			new Action() {	// [17] simple_type = BOOL
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeBoolean();
				}
			},
			new Action() {	// [18] named_type = IDENTIFIER.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					 return new TypeNamed(name);
				}
			},
			Action.RETURN,	// [19] index_type = enumerated_type
			Action.RETURN,	// [20] index_type = subrange_type
			new Action() {	// [21] enumerated_type = init_enumerated_type.init LPAR identifier_list.t_list RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_init = _symbols[offset + 1];
					final TypeEnumRange init = (TypeEnumRange) _symbol_init.value;
					final Symbol _symbol_t_list = _symbols[offset + 3];
					final IdentifierList t_list = (IdentifierList) _symbol_t_list.value;
					 
			TypeEnumRange enum_range = new TypeEnumRange(new TypeItemEnum(0,t_list.first()),new TypeItemEnum(t_list.size()-1,t_list.last()));
			//String name = typeEnvironment.getEnumToName(enum_range);
			Iterator<String> it = t_list.iterator();
			int i = 0;
			while(it.hasNext()) {
				String x =  it.next();
				typeEnvironment.put_enum_value(x,new TypeItemEnum(i,x));
				stackEnvironment.putVariable(x,new TypeItemEnum(i,x));
				//typeEnvironment.putIDtoName(x,name);
				i++;
			}
			return enum_range;
				}
			},
			new Action() {	// [22] init_enumerated_type = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					return new TypeEnumRange();
				}
			},
			new Action() {	// [23] subrange_type = INTEGER_LIT.min DOUBLE_DOT INTEGER_LIT.max
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_min = _symbols[offset + 1];
					final Integer min = (Integer) _symbol_min.value;
					final Symbol _symbol_max = _symbols[offset + 3];
					final Integer max = (Integer) _symbol_max.value;
					 
		boolean test_range_type = true;
		if(min > max) {
			Main.add_error_type(new String("ERROR TypeArrayRange : range not valid" + min + " > " + max));
			test_range_type = false;
		}
		TypeArrayRange type_range = new TypeArrayRange(new TypeInt(min), new TypeInt(max));
		//type_range.setRange_type(test_range_type);
		return type_range;
				}
			},
			new Action() {	// [24] subrange_type = IDENTIFIER.min DOUBLE_DOT IDENTIFIER.max
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_min = _symbols[offset + 1];
					final String min = (String) _symbol_min.value;
					final Symbol _symbol_max = _symbols[offset + 3];
					final String max = (String) _symbol_max.value;
					 
		boolean test_range_type = true;
		TypeItemEnum x = typeEnvironment.get_enum_value(min);
		TypeItemEnum y = typeEnvironment.get_enum_value(max);
		int v_min = x.getValue();
		int v_max = y.getValue();
		if(v_min > v_max) {
			Main.add_error_type(new String("ERROR TypeArrayRange : range not valid " + v_min + " > " + v_max));
			test_range_type = false;
		}
		//if(typeEnvironment.getIDtoName(min)==null || typeEnvironment.getIDtoName(max)==null) {
			//Main.add_error_type(new String("ERROR TypeArrayRange : enum doesn't exist " + v_min + " > " + v_max));
			//test_range_type = false;
		//}
		//if(!typeEnvironment.getIDtoName(min).equals(typeEnvironment.getIDtoName(max))) {
			//Main.add_error_type(new String("ERROR TypeArrayRange : incoherent range " + v_min + " > " + v_max));
			//test_range_type = false;
		//}
		TypeArrayRange one = new TypeArrayRange(new TypeInt(v_min), new TypeInt(v_max));
		one.setFrom_enum(true);
		//one.setRange_type(test_range_type);
		return one;
				}
			},
			new Action() {	// [25] array_type = ARRAY LBRACKET range_type.t1 RBRACKET OF type.t2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t1 = _symbols[offset + 3];
					final Type t1 = (Type) _symbol_t1.value;
					final Symbol _symbol_t2 = _symbols[offset + 6];
					final Type t2 = (Type) _symbol_t2.value;
					
						
										TypeArray array = new TypeArray(t1,t2);
										/*TypeRange test_range_type = array.getRangeOREnum();
										if(test_range_type.isRange_type()==false || test_range_type == null){
		Main.add_error_type(new String("ERROR TypeArray : range type expected " + t1 + "   " + t2));
															}
													*/		
															return array;
				}
			},
			Action.RETURN,	// [26] range_type = enumerated_type
			Action.RETURN,	// [27] range_type = subrange_type
			Action.RETURN,	// [28] range_type = named_type
			new Action() {	// [29] pointer_type = CIRCUMFLEX type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final Type t = (Type) _symbol_t.value;
					 return new TypePointer(t);
				}
			},
			new Action() {	// [30] structure_type = STRUCT LCURLY_BRACKET feature_list_type.t RCURLY_BRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 3];
					final TypeFeatureList t = (TypeFeatureList) _symbol_t.value;
					 return new TypeStruct(t);
				}
			},
			new Action() {	// [31] feature_list_type = feature_list_type.list feature_type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final TypeFeatureList list = (TypeFeatureList) _symbol_list.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeFeature t = (TypeFeature) _symbol_t.value;
					 list.add(t); return list;
				}
			},
			new Action() {	// [32] feature_list_type = feature_type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final TypeFeature t = (TypeFeature) _symbol_t.value;
					 TypeFeatureList list = new TypeFeatureList(); list.add(t); return list;
				}
			},
			new Action() {	// [33] feature_type = IDENTIFIER.id COLON type.t SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					 return new TypeFeature(id, t);
				}
			},
			Action.NONE,  	// [34] variable_declaration_part = 
			RETURN2,	// [35] variable_declaration_part = VAR variable_declaration_list; returns 'variable_declaration_list' although none is marked
			new Action() {	// [36] variable_declaration_list = variable_declaration_list.list variable_declaration.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final NodeList list = (NodeList) _symbol_list.value;
					final Symbol _symbol_name = _symbols[offset + 2];
					final NodeList name = (NodeList) _symbol_name.value;
					 list.add(name); return list;
				}
			},
			new Action() {	// [37] variable_declaration_list = variable_declaration.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final NodeList name = (NodeList) _symbol_name.value;
					 NodeList list = new NodeList(); list.add(name); return list;
				}
			},
			new Action() {	// [38] variable_declaration = identifier_list.list COLON type.t SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final IdentifierList list = (IdentifierList) _symbol_list.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					 
		NodeList list_2 = new NodeList();
		Iterator<String> it = list.iterator();
		while(it.hasNext()) {
			String x =  it.next();
			
			list_2.add(new NodeId(x,t));
			stackEnvironment.putVariable(x,t);
		}
		return list_2;
				}
			},
			new Action() {	// [39] identifier_list = identifier_list.list COMMA IDENTIFIER.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final IdentifierList list = (IdentifierList) _symbol_list.value;
					final Symbol _symbol_name = _symbols[offset + 3];
					final String name = (String) _symbol_name.value;
					 list.add(name); return list;
				}
			},
			new Action() {	// [40] identifier_list = IDENTIFIER.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					 IdentifierList list = new IdentifierList(); list.add(name); return list;
				}
			},
			Action.NONE,  	// [41] procedure_definition_part = 
			Action.RETURN,	// [42] procedure_definition_part = procedure_definition_list
			new Action() {	// [43] procedure_definition_list = procedure_definition_list.list procedure_definition.func
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final NodeList list = (NodeList) _symbol_list.value;
					final Symbol _symbol_func = _symbols[offset + 2];
					final Node func = (Node) _symbol_func.value;
					 list.add(func); return list;
				}
			},
			new Action() {	// [44] procedure_definition_list = procedure_definition.func
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_func = _symbols[offset + 1];
					final Node func = (Node) _symbol_func.value;
					 NodeList list = new NodeList(); list.add(func); return list;
				}
			},
			new Action() {	// [45] procedure_definition = procedure_definition_head.s block
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol s = _symbols[offset + 1];
					
		NodeCallFct sa = (NodeCallFct)s;
		TypeFunct t = (TypeFunct) sa.getTypeFUNC();
		TypeFunct t2 = (TypeFunct) procedureEnvironment.getFunction(sa.getName());
		if(t2.getDefined()==false) {
			t.setDefined(true);
			t.setDeclared(0);
		}
		else {
			semanticError(" function already defined  ",s);
			System.err.println("ERROR :function already defined  " + sa );
			Main.add_error_type(new String("ERROR NodeCallFct : function already defined  " + sa ));
			
		}
		
		sa.setTypeFUNC(t);
		procedureEnvironment.putFunction(sa.getName(),sa.getTypeFUNC());
		
		return sa;
				}
			},
			new Action() {	// [46] procedure_definition = procedure_definition_head.s SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol s = _symbols[offset + 1];
					
		NodeCallFct sa = (NodeCallFct)s;
		TypeFunct t = (TypeFunct) sa.getTypeFUNC();
		TypeFunct t2 = (TypeFunct) procedureEnvironment.getFunction(sa.getName());
		int x = t2.getDeclared();
		t.setDeclared(++x);
		if(t.getDeclared()>1) {
			semanticError(" procedure or function declared twice  ",s);
			System.err.println("ERROR :procedure or function declared twice  " + sa );
			Main.add_error_type(new String("ERROR NodeCallFct : procedure or function declared twice  " + sa ));
		}
		
		sa.setTypeFUNC(t);
		procedureEnvironment.putFunction(sa.getName(),sa.getTypeFUNC());
		
		return sa;
				}
			},
			Action.RETURN,	// [47] procedure_definition_head = procedure_head
			new Action() {	// [48] procedure_head = PROCEDURE IDENTIFIER.func LPAR argt_part.list RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_func = _symbols[offset + 2];
					final String func = (String) _symbol_func.value;
					final Symbol _symbol_list = _symbols[offset + 4];
					final NodeList list = (NodeList) _symbol_list.value;
					 
		
		TypeTuple lionel = new TypeTuple();
		Iterator<Node> it = list.iterator();
		while(it.hasNext()) {
			NodeId x = (NodeId) it.next();		
			lionel.add( new TypeFeature(func,x.getType()));
			stackEnvironment.putVariable(x.getName(),x.getType());
		}

		TypeFunct lionel_le_boss = new TypeFunct(func, lionel, new TypeVoid());
		procedureEnvironment.putFunction(func,lionel_le_boss);
		
		return new NodeCallFct(func,new TypeFunct(func, lionel, new TypeVoid()), list);
				}
			},
			new Action() {	// [49] procedure_head = FUNCTION IDENTIFIER.func LPAR argt_part.list RPAR COLON type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_func = _symbols[offset + 2];
					final String func = (String) _symbol_func.value;
					final Symbol _symbol_list = _symbols[offset + 4];
					final NodeList list = (NodeList) _symbol_list.value;
					final Symbol _symbol_t = _symbols[offset + 7];
					final Type t = (Type) _symbol_t.value;
					 
		
		TypeTuple lionel = new TypeTuple();
		Iterator<Node> it = list.iterator();
		while(it.hasNext()) {
			NodeId x = (NodeId) it.next();	
			lionel.add( new TypeFeature(func,x.getType()));
			stackEnvironment.putVariable(x.getName(),x.getType());
		}

		TypeFunct lionel_le_boss = new TypeFunct(func, lionel, t);
		if(procedureEnvironment.is_null(func))
			procedureEnvironment.putFunction(func,lionel_le_boss);

		return new NodeCallFct(func,new TypeFunct(func, lionel, t), list);
				}
			},
			Action.NONE,  	// [50] argt_part = 
			Action.RETURN,	// [51] argt_part = argt_list
			new Action() {	// [52] argt_list = argt_list.list COMMA argt.arg
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final NodeList list = (NodeList) _symbol_list.value;
					final Symbol _symbol_arg = _symbols[offset + 3];
					final Node arg = (Node) _symbol_arg.value;
					 list.add(arg); return list;
				}
			},
			new Action() {	// [53] argt_list = argt.arg
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_arg = _symbols[offset + 1];
					final Node arg = (Node) _symbol_arg.value;
					 NodeList list = new NodeList(); list.add(arg); return list;
				}
			},
			new Action() {	// [54] argt = IDENTIFIER.name COLON type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					 return new NodeId(name, t);
				}
			},
			new Action() {	// [55] block = push_stack variable_declaration_part BEGIN statement_list.l END pop_stack
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 4];
					final Node l = (Node) _symbol_l.value;
					return l;
				}
			},
			new Action() {	// [56] statement_list = statement_list.list statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final Node list = (Node) _symbol_list.value;
					final Symbol _symbol_stm = _symbols[offset + 2];
					final Node stm = (Node) _symbol_stm.value;
					 list.add(stm); return list;
				}
			},
			new Action() {	// [57] statement_list = statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_stm = _symbols[offset + 1];
					final Node stm = (Node) _symbol_stm.value;
					 NodeList list = new NodeList(); list.add(stm); return list;
				}
			},
			Action.RETURN,	// [58] statement = simple_statement
			Action.RETURN,	// [59] statement = structured_statement
			Action.RETURN,	// [60] simple_statement = assignment_statement
			Action.RETURN,	// [61] simple_statement = procedure_statement
			Action.RETURN,	// [62] simple_statement = new_statement
			Action.RETURN,	// [63] simple_statement = dispose_statement
			Action.RETURN,	// [64] simple_statement = print_statement
			Action.RETURN,	// [65] simple_statement = println_statement
			Action.RETURN,	// [66] simple_statement = readln_statement
			Action.RETURN,	// [67] simple_statement = return_statement
			new Action() {	// [68] assignment_statement = variable_access.stm EQ expression.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_stm = _symbols[offset + 1];
					final NodeExp stm = (NodeExp) _symbol_stm.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 

		if(stm.getType()!=null && e.getType()!=null && !stm.getType().equals(e.getType())){
			if(stm.getType() instanceof TypeNamed){
				Type t = typeEnvironment.getVariableValue(((TypeNamed)stm.getType()).get_name());
				if(t instanceof TypePointer ) {
					return new NodeAssign(stm, e);
				}
			}
			else {	
				if(stm.getType() instanceof TypePointer && e.getType() instanceof TypePointer ) {
					TypeComplex ptr = (TypeComplex)e.getType();
					if(ptr.size()==0)
						return new NodeAssign(stm, new NodeLiteral((new TypePointer((TypePointer) stm.getType()).get(0)),0));
					else if(ptr.size()==1)
						return new NodeAssign(stm, new NodeLiteral((new TypePointer((TypePointer) e.getType()).get(0)),0));
				}
				semanticError("Type error in affectation", e);
				System.err.println(new String("ERROR  : Type error in affectation " + stm.getType() + "  : " + e.getType()));
				Main.add_error_type(new String("ERROR NodeAssign: Type error in affectation " + stm.getType() + "  : " + e.getType()));
			}
		}
		return new NodeAssign(stm, e);
				}
			},
			new Action() {	// [69] procedure_statement = procedure_expression.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final Node e = (Node) _symbol_e.value;
					return e;
				}
			},
			new Action() {	// [70] procedure_expression = IDENTIFIER.func LPAR expression_part.list RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_func = _symbols[offset + 1];
					final String func = (String) _symbol_func.value;
					final Symbol _symbol_list = _symbols[offset + 3];
					final NodeList list = (NodeList) _symbol_list.value;
					 	
		TypeFunct lionel_le_boss = (TypeFunct)procedureEnvironment.getFunction(func);
		//Case Nb params differents
		if(lionel_le_boss.getParams().size() != list.size()) {
			semanticError("Type error in calling expression",list);
			System.err.println("ERROR : Type error in calling expression <NB_PARAM>" + lionel_le_boss + "  : " + list);
			Main.add_error_type(new String("ERROR NodeCallFct : Type error in calling expression <NB_PARAM>" + lionel_le_boss + "  : " + list));
		}
		//Prepare to test the type of parameters
		Iterator<Node> l = list.iterator();
		Iterator <Type> t = lionel_le_boss.getParams().iterator();
		while(l.hasNext() && t.hasNext()) {
			NodeExp n = (NodeExp) l.next();
			TypeFeature m = (TypeFeature) t.next();
			//Type Parameters different
			if(m.get(0)!=null && n.getType()!= null && !n.getType().equals(m.get(0))) {
				semanticError(" Type error in calling expression",list);
				System.err.println("ERROR : Type error in calling expression <BAD TYPES PARAMS>" + lionel_le_boss + "  : " + list);
				Main.add_error_type(new String("ERROR NodeCallFct : Type error in calling expression <BAD TYPES PARAMS>" + lionel_le_boss + "  : " + list));
			}
		}
		
		return new NodeCallFct(func, 
				lionel_le_boss, list);
				}
			},
			Action.NONE,  	// [71] expression_part = 
			Action.RETURN,	// [72] expression_part = expression_list
			new Action() {	// [73] expression_list = expression_list.list COMMA expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final NodeList list = (NodeList) _symbol_list.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 list.add(e); return list;
				}
			},
			new Action() {	// [74] expression_list = expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 NodeList list = new NodeList(); list.add(e); return list;
				}
			},
			new Action() {	// [75] new_statement = NEW variable_access.stm SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_stm = _symbols[offset + 2];
					final NodeExp stm = (NodeExp) _symbol_stm.value;
						
		NodeId ID = (NodeId) stm;
		if(ID.getType() instanceof TypePointer)
			return new NodeNew(stm);
		else if ( ID.getType() instanceof TypeNamed) {
			TypeNamed name_type = (TypeNamed) ID.getType();
			if(typeEnvironment.getVariableValue(name_type.get_name()) instanceof TypePointer);
				return new NodeNew(stm);
		}
		
		semanticError(" Type error in pointer access expression ",stm);
		System.err.println("ERROR : Type error in pointer access expression " + stm);
		Main.add_error_type(new String("ERROR NodeNew : Type error in pointer access expression " + stm));
		return new NodeNew(new NodeId("ERROR",new TypeVoid()));
				}
			},
			new Action() {	// [76] dispose_statement = DISPOSE variable_access.stm SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_stm = _symbols[offset + 2];
					final NodeExp stm = (NodeExp) _symbol_stm.value;
					 
		NodeId id = (NodeId) stm;
		if(id.getType() instanceof TypePointer)
			return new NodeDispose(stm);
		else
		{
			semanticError(" Type error in pointer access expression ",stm);
			System.err.println("ERROR : Type error in pointer access expression " + stm);
			Main.add_error_type(new String("ERROR NodeDispose : Type error in pointer access expression " + stm));
			return new NodeDispose(new NodeId("ERROR",new TypeVoid()));
		}
				}
			},
			new Action() {	// [77] print_statement = PRINT expression.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 
		return new NodeCallFct("print",
			new TypeFunct("print",new TypeTuple(new TypeFeature("print",e.getType())),
					new TypeVoid()), new NodeList(e));
				}
			},
			new Action() {	// [78] println_statement = PRINTLN expression.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 
		return new NodeCallFct("println",
			new TypeFunct("println",new TypeTuple(new TypeFeature("println",e.getType())),
					new TypeVoid()), new NodeList(e));
				}
			},
			new Action() {	// [79] readln_statement = READLN.func expression.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol func = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 
		return new NodeCallFct("readln", 
			new TypeFunct("readln",new TypeTuple(new TypeFeature("readln",e.getType())),
					new TypeVoid()), new NodeList(e));
				}
			},
			new Action() {	// [80] return_statement = RETURN expression.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return new NodeReturn(e);
				}
			},
			Action.RETURN,	// [81] structured_statement = block
			Action.RETURN,	// [82] structured_statement = if_statement
			Action.RETURN,	// [83] structured_statement = while_statement
			Action.RETURN,	// [84] structured_statement = switch_statement
			new Action() {	// [85] if_statement = IF expression.e THEN statement.stm1 ELSE statement.stm2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					final Symbol _symbol_stm1 = _symbols[offset + 4];
					final Node stm1 = (Node) _symbol_stm1.value;
					final Symbol _symbol_stm2 = _symbols[offset + 6];
					final Node stm2 = (Node) _symbol_stm2.value;
					 return new NodeIf(e, stm1, stm2);
				}
			},
			new Action() {	// [86] if_statement = IF expression.e THEN statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					final Symbol _symbol_stm = _symbols[offset + 4];
					final Node stm = (Node) _symbol_stm.value;
					 return new NodeIf(e, stm);
				}
			},
			new Action() {	// [87] while_statement = WHILE expression.e DO statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					final Symbol _symbol_stm = _symbols[offset + 4];
					final Node stm = (Node) _symbol_stm.value;
					 return new NodeWhile(e, stm);
				}
			},
			new Action() {	// [88] switch_statement = SWITCH expression.e BEGIN case_statement_list.stm END
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					final Symbol _symbol_stm = _symbols[offset + 4];
					final NodeCaseList stm = (NodeCaseList) _symbol_stm.value;
					 return new NodeSwitch(e, stm);
				}
			},
			new Action() {	// [89] case_statement_list = case_statement_list.list case_statement.case1 case_default.case2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final NodeCaseList list = (NodeCaseList) _symbol_list.value;
					final Symbol _symbol_case1 = _symbols[offset + 2];
					final NodeList case1 = (NodeList) _symbol_case1.value;
					final Symbol _symbol_case2 = _symbols[offset + 3];
					final NodeCase case2 = (NodeCase) _symbol_case2.value;
					
		list.add(case1);
		if(case2!=null) list.add(case2);
		return list;
				}
			},
			new Action() {	// [90] case_statement_list = case_statement.case1 case_default.case2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_case1 = _symbols[offset + 1];
					final NodeList case1 = (NodeList) _symbol_case1.value;
					final Symbol _symbol_case2 = _symbols[offset + 2];
					final NodeCase case2 = (NodeCase) _symbol_case2.value;
					 
		NodeCaseList list = new NodeCaseList(); list.add(case1); 
		if(case2!=null) list.add(case2);															
		return list;
				}
			},
			new Action() {	// [91] case_statement = CASE identifier_list.list COLON statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 2];
					final IdentifierList list = (IdentifierList) _symbol_list.value;
					final Symbol _symbol_stm = _symbols[offset + 4];
					final Node stm = (Node) _symbol_stm.value;
					 
		NodeList list_2 = new NodeList();
		Iterator<String> it = list.iterator();
		while(it.hasNext()) {
			String x =  it.next();
			list_2.add(new NodeCase(x,stm));
		}
		return list_2;
				}
			},
			Action.NONE,  	// [92] case_default = 
			new Action() {	// [93] case_default = DEFAULT COLON statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_stm = _symbols[offset + 3];
					final Node stm = (Node) _symbol_stm.value;
					 return new NodeCase(stm);
				}
			},
			new Action() {	// [94] variable_access = IDENTIFIER.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					  
		int x = 0;
		
		if(stackEnvironment.getVariableValue(name)==null && typeEnvironment.get_enum_value(name)== null ) {
			Main.add_error_type(new String("ERROR TypeArrayRange : Type error in array access "));
			return new NodeId("ERROR",new TypeVoid());
		}
		else if(stackEnvironment.getVariableValue(name)!=null && stackEnvironment.getVariableValue(name) instanceof TypeItemEnum) {
			
			x = ((TypeItemEnum)stackEnvironment.getVariableValue(name)).getValue();
			return new NodeId(name,new TypeInt(x));
		}
		else if(stackEnvironment.getVariableValue(name)!=null && stackEnvironment.getVariableValue(name) instanceof TypeNamed) {
			TypeNamed named =  (TypeNamed) stackEnvironment.getVariableValue(name) ;
			return new NodeId(name,typeEnvironment.getVariableValue(named.get_name()));
		}
		
		
		return new NodeId(name, stackEnvironment.getVariableValue(name));
				}
			},
			new Action() {	// [95] variable_access = variable_access.e1 LBRACKET expression.e2 RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 
		return new NodeArrayAccess(e1, e2) ;
				}
			},
			new Action() {	// [96] variable_access = expression.e CIRCUMFLEX
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 
		NodeId ID = (NodeId) e;

		if(ID.getType() instanceof TypePointer)
			return new NodePtrAccess(e);
		else {
		semanticError(" Type error in pointer access expression ",e);
		System.err.println("ERROR : Type error in pointer access expression " + e);
		Main.add_error_type(new String("ERROR NodePtrAccess : Type error in pointer access expression " + e));
		return new NodePtrAccess(new NodeId("Error",new TypeVoid())); 
		}
				}
			},
			new Action() {	// [97] expression = expression.e1 PLUS expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 
		if(e1.getType()!=null && e2.getType()!=null) {
			if(!e1.getType().equals(e2.getType())) {
				Main.add_error_type(new String("ERROR NodeOp : Type error in arithmetic expression"
					+ e1.getType() + " + " + e2.getType()));
			}
		}
		return new NodeOp("+", e1, e2);
				}
			},
			new Action() {	// [98] expression = expression.e1 MINUS expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 
		if(e1.getType()!=null && e2.getType()!=null) {
			if(!e1.getType().equals(e2.getType())) {
				Main.add_error_type(new String("ERROR NodeOp : Type error in arithmetic expression"
						+ e1.getType() + " - " + e2.getType()));
			}
		}
		return new NodeOp("-", e1, e2);
				}
			},
			new Action() {	// [99] expression = MINUS expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 
		if(e.getType()!=null) {
			if(!e.getType().equals(new TypeInt())) {
				Main.add_error_type(new String("ERROR NodeOp : Type error in arithmetic expression"
						+ "-" + e.getType()));
			}
		}
		return new NodeOp("-", e);
				}
			},
			new Action() {	// [100] expression = expression.e1 TIMES expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					
		if(e1.getType()!=null && e2.getType()!=null) {
			if(!e1.getType().equals(e2.getType())) {
				Main.add_error_type(new String("ERROR NodeOp : Type error in arithmetic expression"
					+ e1.getType() + " * " + e2.getType()));
			}
		}
		return new NodeOp("*", e1, e2);
				}
			},
			new Action() {	// [101] expression = expression.e1 DIV expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					
		if(e1.getType()!=null && e2.getType()!=null) {
			if(!e1.getType().equals(e2.getType())) {
				Main.add_error_type(new String("ERROR NodeOp : Type error in arithmetic expression"
						+ e1.getType() + " / " + e2.getType()));
			}
		}
		return new NodeOp("/", e1, e2);
				}
			},
			new Action() {	// [102] expression = expression.e1 AND expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 
		if(e1.getType()!=null && e2.getType()!=null) {
			if(!e1.getType().equals(e2.getType())) { //OK
				Main.add_error_type(new String("ERROR NodeRel : Type error in logical expression"
						+ e1.getType() + " && " + e2.getType()));
			}
		}
		return new NodeRel("&&", e1, e2);
				}
			},
			new Action() {	// [103] expression = expression.e1 OR expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 
		if(e1.getType()!=null && e2.getType()!=null) {
			if(!e1.getType().equals(e2.getType())) { //OK
				Main.add_error_type(new String("ERROR NodeRel : Type error in logical expression"
						+ e1.getType() + " || " + e2.getType()));
			}		
		}
		return new NodeRel("||", e1, e2);
				}
			},
			new Action() {	// [104] expression = NOT expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					
		if(!e.getType().equals(new TypeBoolean())) {
			Main.add_error_type(new String("ERROR NodeRel : Type error in logical expression"
					+ "!" + e.getType()));
		}
		return new NodeRel("!", e);
				}
			},
			new Action() {	// [105] expression = expression.e1 INFERIOR expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					
		if(e1.getType()!=null && e2.getType()!=null) {
			if(!e1.getType().equals(e2.getType()) || (e1.getType().equals(new TypeBoolean()) || e2.getType().equals(new TypeBoolean()) ) ) { //OK
				Main.add_error_type(new String("ERROR NodeRel : Type error in comparison"
						+ e1.getType() + " < " + e2.getType()));
			}
		}
		return new NodeRel("<", e1, e2);
				}
			},
			new Action() {	// [106] expression = expression.e1 INFERIOR_EQ expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					
		if(e1.getType()!=null && e2.getType()!=null) {
			if(!e1.getType().equals(e2.getType()) || (e1.getType().equals(new TypeBoolean()) || e2.getType().equals(new TypeBoolean()) ) ) { //OK
				Main.add_error_type(new String("ERROR NodeRel : Type error in comparison"
						+ e1.getType() + " <= " + e2.getType()));
			}
		}
		return new NodeRel("<=", e1, e2);
				}
			},
			new Action() {	// [107] expression = expression.e1 SUPERIOR expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					
		if(e1.getType()!=null && e2.getType()!=null) { //OK
			if(!e1.getType().equals(e2.getType()) || (e1.getType().equals(new TypeBoolean()) || e2.getType().equals(new TypeBoolean()) ) ) {
				Main.add_error_type(new String("ERROR NodeRel : Type error in comparison"
					+ e1.getType() + " > " + e2.getType()));
			}
		}												
		return new NodeRel(">", e1, e2);
				}
			},
			new Action() {	// [108] expression = expression.e1 SUPERIOR_EQ expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					
		if(e1.getType()!=null && e2.getType()!=null) {
			if(!e1.getType().equals(e2.getType()) || (e1.getType().equals(new TypeBoolean()) || e2.getType().equals(new TypeBoolean()) ) ) { //OK
				Main.add_error_type(new String("ERROR NodeRel : Type error in comparison"
					+ e1.getType() + " >= " + e2.getType()));
			}
		}
		return new NodeRel(">=", e1, e2);
				}
			},
			new Action() {	// [109] expression = expression.e1 EQUALS expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 
		if(e1.getType()!=null && e2.getType()!=null) {
			if(!e1.getType().equals(e2.getType())) { //OK
				Main.add_error_type(new String("ERROR NodeRel : Type error in comparison"
					+ e1.getType() + " == " + e2.getType()));
			}
		}
		return new NodeRel("==", e1, e2);
				}
			},
			new Action() {	// [110] expression = expression.e1 DIFF expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 
		if(e1.getType()!=null && e2.getType()!=null) { //OK
			if(!e1.getType().equals(e2.getType())) {
				Main.add_error_type(new String("ERROR NodeRel : Type error in comparison"
					+ e1.getType() + " != " + e2.getType()));
			}
		}
		return new NodeRel("!=", e1, e2);
				}
			},
			new Action() {	// [111] expression = LPAR expression.e RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return e;
				}
			},
			Action.RETURN,	// [112] expression = procedure_expression
			Action.RETURN,	// [113] expression = variable_access
			Action.RETURN,	// [114] expression = literal
			new Action() {	// [115] literal = INTEGER_LIT.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final Integer e = (Integer) _symbol_e.value;
					 return new NodeLiteral(new TypeInt(e), e);
				}
			},
			new Action() {	// [116] literal = STRING_LIT.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final String e = (String) _symbol_e.value;
					 return new NodeLiteral(new TypeString(), e);
				}
			},
			new Action() {	// [117] literal = TRUE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NodeLiteral(new TypeBoolean(), true);
				}
			},
			new Action() {	// [118] literal = FALSE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NodeLiteral(new TypeBoolean(), false);
				}
			},
			new Action() {	// [119] literal = NULL
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NodeLiteral(new TypePointer(), null);
				}
			}
		};

 
	report = new Events();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
