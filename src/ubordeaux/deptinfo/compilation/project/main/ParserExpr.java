package ubordeaux.deptinfo.compilation.project.main;

import java.util.Iterator;
import ubordeaux.deptinfo.compilation.project.environment.*;
import ubordeaux.deptinfo.compilation.project.type.*;
import beaver.*;
import java.util.ArrayList;
import ubordeaux.deptinfo.compilation.project.node.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "ParserExpr.grammar".
 */
public class ParserExpr extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjLsTu5LKGFRlx04M8YcA84WL40mbDGLH4EYWglGGGec1G4bGisB1B2IZD058KAG6feg8" +
		"8qWqe5Z1AKL0KmOQzOtSykvdTRDvkdadm#$p3Uz$PcJltt9cvktVlpWKYSz4L9w43ckCALC" +
		"8pE1hbSGmge2BYS2oEm$4u0IUYCbgW8Sx5HJW75wCzBi6biXjRiG1bPL#m3xVX4Lo5wz09t" +
		"T0JlT4N6QY22z24SInPm$xDM8LofOrD$WgKGV$ms2A1s47M09oCdSWh8ljj0G$#J8ygGQPL" +
		"ysTTH9oJ$xCufnv6dAjB4AVQOSGPL88uDGuZphKbY5FpCEBSMe8uPyQCqpHcdAUAZ9E8cLY" +
		"CXLY4Dv276vdlAJWDrR4Kf#CC9A4sKb0NzN4M4iYzJD$0OMY9yHxtZW0t4IREHorbTtIPyb" +
		"20cQoSP$4SHxN6Iiwa3LhXIiHx$fi5HlKYjuwEN8hfkCcBi3h0lPpSUieTYflHrlFR9S1D8" +
		"xU1Scz13dDnkLD3vdYsCdDmDqPxp341vZXo6obt0YPYeCST4k1E8RUnSgTZ6WPxt1aX6Pod" +
		"pCVmEBDmcRD2c1SgSoxcumdlRdqMOCx4lNWG3#4kt8FxS3yUm73Fzd28RLA8xT4GMsw8xRK" +
		"Gsri#Mt2T7x6Kr98bdygNc8UdgNtYQDd8GewdtU1gia#rThfIil4yzvKdCHQJCG8ZCQhOMX" +
		"RkT7pDeVQ2Uat4wtp3Dr5RYTM8U6jr3TPXEVUgpaxChkZko32lYUWXxs0PvMnwNkjvS6KYD" +
		"l9ztO14UOFzBuRqsnN3ovGlOJrU3UbFrPc$WXtyk$O#QksdCbrbfihhlJqn2vkSsMxaVmdU" +
		"n7O0Mx1EVeF$TpkYVf8dUTmjcz1FKxwdpUYh1VVNLjmDst2tQiVdwJvDW$kgnRjN1cLP#zX" +
		"VzpW#xxxS3#D2#ghmAs3FeYhdTYhdKespAOYJmFwwt1bJIXtRviSL6Hk1s45M2hzAVRX3Xt" +
		"ku9aRs9SlK7HSUf$oHE4VYC4wjKiOnMHTrO9NJoLdBALwbrK0hhKfQQvt4ciRqVFPa$44Uj" +
		"r#0QxAYI$3OyHxp#W3JvQInrZCvPW1dSYshmJZMIEwesZ5pQS3xqTlZ9iJaDcQrd#nnusDo" +
		"a#YtbiTj6397bsbmN7sFQGIOjNpSsgnJ6WNgsGBksONyzkNNqEKcnSWWdi$3y9WzO#PQdok" +
		"dw3lhheREh32xiYBlZXx$cosupezOIcwfxLXwUrfvQeQd3VIqEDNSbLAUgweArr8DrjarMM" +
		"cVMMpDu5grVINx8fdE6vvARG0jwTuAl1BzUKvmOxeopAl9VEBesTubaWdNWojDvtrDrVwaa" +
		"7wxOh0SNdY$6pt1oTkrH#TMbEp9CQdEREtH$RX$nOiuywiZlXyo9Uh7U0ciE7RTPzTJ8fzI" +
		"r23YY8x4ZKGb8iFkBmq0GtX9eznROEEP1JnxWgTNiBe5FYCEadCAKPNe14IEennEUHRbIif" +
		"p02k5iYLb8ygsb1TITg5iHzc3qXxNdx8NntIcf6wCeCoa$C6NqmpQRWRCSZxRBxnKewr2Vj" +
		"kiIyvTbFF3vsMkvfZVydLh9DjjrPx7zdZcaQXzKscheVfiwkUfleXwHnt3EVDy2NJMlkMqf" +
		"LFPexbLLFiQskzWkwMsDxCzWJYMjjNgwpILRMYxHVN1nBqwvW2nZUtCuZz3ininAiesY7Fa" +
		"yp6l8wwcp#tg$ntj7qei8Phxnenb$rxAnThUGEJIZvlpBXzt8R7Jr#OwiPuWbcYStHndptj" +
		"HuRmYITg$AyfUaQXCP17LrLQVQAtwwHoptyTF9JZlo6Z2NbSD2TzwYTZppr3z2g82eVSxab" +
		"x0CnRmlVg3lbVORUfRAFeKzzuN1TjduVdXLfLwR$61ng#aiftAOIftgFmaNvgcoYegwwdK#" +
		"sFsLZb4vOZed6YR7hGPQmkthMN5cHzv1wFQNnNeaHIVtjYdDoayXjyYOBpsDLDRhif3Qc#b" +
		"UIPhM##JPRzd1xNlEzzyqfJ7$S78ySrzHd7czU$pDYRvVCvJwTqpFdU#BsQNmcFCLL7jcqe" +
		"NsvgcEMH7vRGvNoAnY77hezhV#dB93V8ZzNpzMmjqVczXZF7rlHqSYrsy2t$BFdW$ULMsoC" +
		"loacoMJP8hByf6sI3BvHbvMfwIR8UnNd9udKlC8MOHZnCpYSS8VWraEZ6Du6ujZn1JYDd4e" +
		"yxuoJ99FSsJXsM#ewrrhY$8H9aWusMSZ9LLPAsZBLjMEdtPyhmZLpZNvvphivhpQogN4K#g" +
		"ljIRqH9P88iTZJkUV23lg$qz#LL#aKFoi$maFyeFyhry9z$I$hby8r$xxWY$fVAnwX$90TK" +
		"#LFaLyQxiSVGlPBzQzwfSA8la5SgtYPsoGxPxNjzohjkSw#ko5RwVl2dsS$bB$jJsxmHtFG" +
		"pbkQiiJsGWJ5pZmE1vBy8Jdy6AEnnTVEX0T5LqvBZBwAiJQnqRtUXx4EqkkjD$3t8oA3ESC" +
		"qo4Pr0G9Z8TsDLHn3b3sZMJ$OrDfnpCli6KQKwjQB9QD5WhbY7AiOe2OR2MieZyEgiPVVGY" +
		"hnVRpHKjOg0L#Qt9lu2Itql2u4dJ8WoUYYsUYosUZ2sUZIsUZYsUbur2QCznxJdNIoWlPLv" +
		"svJpGENj6UAe4OR4ID8W8OLUJbiAlnxBvONXe6e8X$m25uVlN");

	static final Action RETURN6 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 6];
		}
	};

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN7 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 7];
		}
	};
 
	static class Events extends beaver.Parser.Events {
		public void syntaxError(Symbol token) {
			System.err.format("*** Erreur de syntaxe en ligne %d, colonne %d. Token inattendu: %s\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()),
				Terminals.NAMES[token.getId()]);
		}
	}
	
	public void semanticError(String msg, Symbol token) {
			System.err.format("*** " + msg + " ligne %d, colonne %d\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()));
		}
		
	private Environment typeEnvironment = new Environment("types");
	private Environment procedureEnvironment = new Environment("procedures");
	private StackEnvironment stackEnvironment = new StackEnvironment("local variables stack");
	private String type_declaration_name;

	private final Action[] actions;

	public ParserExpr() {
		super(PARSING_TABLES);
		actions = new Action[] {
			RETURN6,	// [0] program = type_declaration_part variable_declaration_part procedure_definition_part BEGIN statement_list END; returns 'END' although none is marked
			Action.NONE,  	// [1] type_declaration_part = 
			RETURN2,	// [2] type_declaration_part = TYPE type_declaration_list; returns 'type_declaration_list' although none is marked
			new Action() {	// [3] type_declaration_list = type_declaration_list type_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [4] type_declaration_list = type_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN4,	// [5] type_declaration = type_declaration_head EQ type SEMI; returns 'SEMI' although none is marked
			Action.RETURN,	// [6] type_declaration_head = IDENTIFIER
			Action.RETURN,	// [7] type = simple_type
			Action.RETURN,	// [8] type = named_type
			Action.RETURN,	// [9] type = index_type
			Action.RETURN,	// [10] type = array_type
			Action.RETURN,	// [11] type = pointer_type
			Action.RETURN,	// [12] type = structure_type
			new Action() {	// [13] simple_type = STR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeString();
				}
			},
			new Action() {	// [14] simple_type = INT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeInt();
				}
			},
			new Action() {	// [15] simple_type = BOOL
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeBoolean();
				}
			},
			Action.RETURN,	// [16] named_type = IDENTIFIER
			Action.RETURN,	// [17] index_type = enumerated_type
			Action.RETURN,	// [18] index_type = subrange_type
			RETURN4,	// [19] enumerated_type = init_enumerated_type LPAR identifier_list RPAR; returns 'RPAR' although none is marked
			Action.NONE,  	// [20] init_enumerated_type = 
			RETURN3,	// [21] subrange_type = INTEGER_LIT DOUBLE_DOT INTEGER_LIT; returns 'INTEGER_LIT' although none is marked
			RETURN3,	// [22] subrange_type = IDENTIFIER DOUBLE_DOT IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN6,	// [23] array_type = ARRAY LBRACKET range_type RBRACKET OF type; returns 'type' although none is marked
			Action.RETURN,	// [24] range_type = enumerated_type
			Action.RETURN,	// [25] range_type = subrange_type
			Action.RETURN,	// [26] range_type = named_type
			new Action() {	// [27] pointer_type = CIRCUMFLEX type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final Type t = (Type) _symbol_t.value;
					 return new TypePointer(t);
				}
			},
			new Action() {	// [28] structure_type = STRUCT LCURLY_BRACKET feature_list_type.t RCURLY_BRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 3];
					final TypeFeatureList t = (TypeFeatureList) _symbol_t.value;
					 return new TypeStruct(t);
				}
			},
			new Action() {	// [29] feature_list_type = feature_list_type feature_type
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [30] feature_list_type = feature_type
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [31] feature_type = IDENTIFIER.id COLON type.t SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					 return new TypeFeature(id, t);
				}
			},
			Action.NONE,  	// [32] variable_declaration_part = 
			RETURN2,	// [33] variable_declaration_part = VAR variable_declaration_list; returns 'variable_declaration_list' although none is marked
			new Action() {	// [34] variable_declaration_list = variable_declaration_list variable_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [35] variable_declaration_list = variable_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN4,	// [36] variable_declaration = identifier_list COLON type SEMI; returns 'SEMI' although none is marked
			new Action() {	// [37] identifier_list = identifier_list COMMA IDENTIFIER
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [38] identifier_list = IDENTIFIER
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			Action.NONE,  	// [39] procedure_definition_part = 
			Action.RETURN,	// [40] procedure_definition_part = procedure_definition_list
			new Action() {	// [41] procedure_definition_list = procedure_definition_list procedure_definition
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [42] procedure_definition_list = procedure_definition
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN2,	// [43] procedure_definition = procedure_definition_head block; returns 'block' although none is marked
			RETURN2,	// [44] procedure_definition = procedure_definition_head SEMI; returns 'SEMI' although none is marked
			Action.RETURN,	// [45] procedure_definition_head = procedure_head
			RETURN5,	// [46] procedure_head = PROCEDURE IDENTIFIER LPAR argt_part RPAR; returns 'RPAR' although none is marked
			RETURN7,	// [47] procedure_head = FUNCTION IDENTIFIER LPAR argt_part RPAR COLON type; returns 'type' although none is marked
			Action.NONE,  	// [48] argt_part = 
			Action.RETURN,	// [49] argt_part = argt_list
			new Action() {	// [50] argt_list = argt_list COMMA argt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [51] argt_list = argt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN3,	// [52] argt = IDENTIFIER COLON type; returns 'type' although none is marked
			RETURN4,	// [53] block = variable_declaration_part BEGIN statement_list END; returns 'END' although none is marked
			new Action() {	// [54] statement_list = statement_list statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [55] statement_list = statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [56] statement = simple_statement
			Action.RETURN,	// [57] statement = structured_statement
			Action.RETURN,	// [58] simple_statement = assignment_statement
			Action.RETURN,	// [59] simple_statement = procedure_statement
			Action.RETURN,	// [60] simple_statement = new_statement
			Action.RETURN,	// [61] simple_statement = dispose_statement
			Action.RETURN,	// [62] simple_statement = println_statement
			Action.RETURN,	// [63] simple_statement = readln_statement
			Action.RETURN,	// [64] simple_statement = return_statement
			RETURN3,	// [65] assignment_statement = variable_access.stm EQ expression.e SEMI; returns 'e' although more are marked
			Action.RETURN,	// [66] procedure_statement = procedure_expression.e SEMI
			RETURN3,	// [67] procedure_expression = IDENTIFIER LPAR expression_part.e RPAR
			Action.NONE,  	// [68] expression_part = 
			Action.RETURN,	// [69] expression_part = expression_list
			new Action() {	// [70] expression_list = expression_list COMMA expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [71] expression_list = expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [72] new_statement = NEW variable_access.stm SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_stm = _symbols[offset + 2];
					final NodeExp stm = (NodeExp) _symbol_stm.value;
					 return new NodeNew(stm);
				}
			},
			new Action() {	// [73] dispose_statement = DISPOSE variable_access.stm SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_stm = _symbols[offset + 2];
					final NodeExp stm = (NodeExp) _symbol_stm.value;
					 return new NodeDispose(stm);
				}
			},
			RETURN2,	// [74] println_statement = PRINTLN expression.e SEMI
			RETURN2,	// [75] readln_statement = READLN expression.e SEMI
			RETURN2,	// [76] return_statement = RETURN expression.e SEMI
			Action.RETURN,	// [77] structured_statement = block.block
			Action.RETURN,	// [78] structured_statement = if_statement
			Action.RETURN,	// [79] structured_statement = while_statement
			Action.RETURN,	// [80] structured_statement = switch_statement
			RETURN4,	// [81] if_statement = IF expression.e THEN statement.stm; returns 'stm' although more are marked
			RETURN6,	// [82] if_statement = IF expression.e THEN statement.stm1 ELSE statement.stm2; returns 'stm2' although more are marked
			RETURN4,	// [83] while_statement = WHILE expression.e DO statement.stm; returns 'stm' although more are marked
			RETURN4,	// [84] switch_statement = SWITCH expression.e BEGIN case_statement_list.stm END; returns 'stm' although more are marked
			RETURN3,	// [85] case_statement_list = case_statement_list case_statement case_default; returns 'case_default' although none is marked
			Action.RETURN,	// [86] case_statement_list = case_statement
			RETURN4,	// [87] case_statement = CASE identifier_list COLON statement; returns 'statement' although none is marked
			Action.NONE,  	// [88] case_default = 
			RETURN3,	// [89] case_default = DEFAULT COLON statement; returns 'statement' although none is marked
			Action.RETURN,	// [90] variable_access = IDENTIFIER
			RETURN4,	// [91] variable_access = variable_access LBRACKET expression RBRACKET; returns 'RBRACKET' although none is marked
			RETURN2,	// [92] variable_access = expression CIRCUMFLEX; returns 'CIRCUMFLEX' although none is marked
			RETURN3,	// [93] expression = expression.e1 PLUS expression.e2; returns 'e2' although more are marked
			RETURN3,	// [94] expression = expression.e1 MINUS expression.e2; returns 'e2' although more are marked
			RETURN2,	// [95] expression = MINUS expression.e
			RETURN3,	// [96] expression = expression.e1 TIMES expression.e2; returns 'e2' although more are marked
			RETURN3,	// [97] expression = expression.e1 DIV expression.e2; returns 'e2' although more are marked
			RETURN3,	// [98] expression = expression.e1 AND expression.e2; returns 'e2' although more are marked
			RETURN3,	// [99] expression = expression.e1 OR expression.e2; returns 'e2' although more are marked
			RETURN2,	// [100] expression = NOT expression.e
			RETURN3,	// [101] expression = expression.e1 INFERIOR expression.e2; returns 'e2' although more are marked
			RETURN3,	// [102] expression = expression.e1 INFERIOR_EQ expression.e2; returns 'e2' although more are marked
			RETURN3,	// [103] expression = expression.e1 SUPERIOR expression.e2; returns 'e2' although more are marked
			RETURN3,	// [104] expression = expression.e1 SUPERIOR_EQ expression.e2; returns 'e2' although more are marked
			RETURN3,	// [105] expression = expression.e1 EQUALS expression.e2; returns 'e2' although more are marked
			RETURN3,	// [106] expression = expression.e1 DIFF expression.e2; returns 'e2' although more are marked
			new Action() {	// [107] expression = LPAR expression.e RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e = _symbols[offset + 2];
					 return e;
				}
			},
			Action.RETURN,	// [108] expression = procedure_expression
			Action.RETURN,	// [109] expression = variable_access
			Action.RETURN,	// [110] expression = literal
			Action.RETURN,	// [111] literal = INTEGER_LIT
			Action.RETURN,	// [112] literal = STRING_LIT
			Action.RETURN,	// [113] literal = TRUE
			Action.RETURN,	// [114] literal = FALSE
			Action.RETURN	// [115] literal = NULL
		};

 
	report = new Events();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
