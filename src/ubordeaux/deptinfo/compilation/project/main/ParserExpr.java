package ubordeaux.deptinfo.compilation.project.main;

import java.util.Iterator;
import ubordeaux.deptinfo.compilation.project.environment.*;
import ubordeaux.deptinfo.compilation.project.type.*;
import beaver.*;
import java.util.ArrayList;
import ubordeaux.deptinfo.compilation.project.main.*;
import ubordeaux.deptinfo.compilation.project.node.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "ParserExpr.grammar".
 */
public class ParserExpr extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjcNcO5DKLnKzr5mx1BObc9W8wGS8CGW1nYGHmH3P14MIJLL4H10P7CCPWCAXWeeW2BkE" +
		"#02A2e0BA8gAeh8e2Rg0cAYw9Q8W9BZ4HzVchudPFpNJtK6Z#yFkqvpjrxhlllFkMgdfrtp" +
		"UIFqczz7Drq$4wKmVgSksjVRIlzjF##h5#ef$g0FrC#IhGN5sZctMBhjBLcgmfcgfhQR5Cp" +
		"ojl3oFS5OdmebvIKcTNYb0hPuGzLus8fHePIpKgbkeFiLINvbIrrT7wZJhh69seazH59sVn" +
		"TDMnQasaF#aSZLPtzLPV3T3fEbU938#lccupQxz83#bXhTRJUan3ulJYdjDUwgZskhrgJ3S" +
		"nevSuewwzQzJkoupMF$f6yGwnU2wZTTqOyKgo#7vXwrgrTQ5xH8TQtMgYrzN1ggVwQg1Y7Q" +
		"R6Qg9cQguZLKU5#gNfKB62kPI5QgKYKzvRJSJKEpEzufrnBzEweRKDxcQRdAtxesnaodjGj" +
		"SkfF0tbhqpPGQVeh9pACr0sDULW3NLBgvdZuQOxGQKQcrDtXAaATPHP5sgCXkVKPzwtysZx" +
		"QslxU$rM3rGpfXQc#wCkSyzMesjfkfMwI1VlzlxCYUnfAT$QBBwDMNoR8xuup$qFdk#ofro" +
		"$S#$hGVN46XjQqx36fQqnQQl4hEFiIPkc2RfLCtIThjSDiQrodkCWpcLOaonYeJRf4VN1Me" +
		"vT8$tqtgWbQVictSOUc2rYePRIkWHUhdKwADqYnOMwGq$eANYTnklkBFNFKdi1V2TxswoC#" +
		"austrxgONngoFtCFz1uaF4mupBZyuslLBbxFPpngsGHbr1UgCMyrnFvBixMVLWlw0hDOsLc" +
		"wi#wN$ErmFtDlUlUqQDwN2lq97lvAgtHCrglvxH1h$3tigGjalkCkzgIFRerVPLmXzhGNrl" +
		"sp$RiZXtPppfnpok#njtOCRipcvxCfNVOeWMp#UOHJkEhCpHsXE#3oYEpIPBBr20doLDDCe" +
		"PCJofIS$AiWyWsweHFt24yXyTcUFhoNInAhxt7jwy9dZYz5D2kZ2$EY8oOep8yUp9gPRJk$" +
		"t#ELoj6lE9g8bPjdM0jKdKUqRDbv0U6MMqYhGjK1JcLSIDcUsUA8hq4TxDXhF4SXIePIrb0" +
		"gMyiPH5thhevfdI7aRCqowbBgIhq0yYdZiwfpxnlnqJQ3cHKySRanTGrODVUa$lpRNnndli" +
		"VFDzjJwFGau$LBBHgONbfw$2qLMnMnOuna7DPFSvVzJbRnRLIiGFEjuW9JjvdKQh5#JSu9w" +
		"UUtgQSy59sq7znreYxMXV3GyYi6gTRf3Z1ZZDOPyDzU5EFp58Vr0w3Zw2NGHdrgVb#MpwLw" +
		"4NXZ8Ci8dXB1t5c2zxNvY0VQpZb9AfIZQIsASg6uLz#k6O5NFkWt6Kt25UmCMViVD2Ohyfh" +
		"bt89u9nx3ve7reF0$XzO8tajm1aftPv2Ihuh9VeGOqg5Bx6QyY1u0pmP9alpfiDRuHdm#xH" +
		"Z38cFu7$2EoL$BsmVhWNl2#V3mAyD5y95S4Eu4ToSE4lWbl07S3juPaN$NYzyNU2b4HzzUM" +
		"F13XjZJJIzuQnpnty1sezjZgU3SlDVYNqEs6nrez1jCViYxErcZqVhxRBzO8q$0maA6oDhD" +
		"maDS$JgWIz08$FVW9zvUfsjV0Vbje3rIOwpSTGsBaNNmspcvvUWMM1p7Xtfwug8$IPusyR6" +
		"sYLdWVIuTWUqQy7dLNnau$v0U0VWVYRdcd##yNRgcp2c5HLj$0xu5y6zhJmIdCSyR3v#Hn2" +
		"PWzyLT0EdsFmMcdzmvR7ut0T$3CQdy11Rcw7O5rjzV$fT5j5V0iOHxqQOzVI3#$r6f7u2kD" +
		"pi0TIz0vzlvK4LEitXFNiDlWdDnC17cRLYJ#MTYxk#kS1lP#MoLz#uYt5$upBZ2SRJZHSRh" +
		"pVUQlo9hL6UyJx6zZmcIenxP8wfuhcAZ7DQ5OsBDpy$MQMS5x7tZjZxH#m3AknTpmDhlWsg" +
		"ItcLQGfiNCsCsvg$ZfLJpr#XZNSbRJ#qEKVwrJ3pjQeotx6HkGwFZ8qzpTylLGwUXJZhi3l" +
		"mcnM9kStcFhvolybDbTjKldTe3exVNtAszRKrH$sIAh6B8$qEpA9V4waV6cddqyTRaRfHMU" +
		"RE##M#Sb#uruC2rbSXhtMhtIgtqZtbddHFk1NkSVUOc#yUT0#u#ztKKB7SyGLoqy1TW1tLt" +
		"Gvk0xU2cm5lhMC7SEM07TXT3#u4juJjhtFNMgGPRegxExIMXTSbRhAxnbtj9hcht69KZ#AR" +
		"wXQ5TLFTmo4$55uNXjS5gP6xBzqwi#U2UMRV9$kvEUuUDplqpJJFAzYpt1Ryzpg#tkwlxYz" +
		"MywhxZ$lKVU8#TX#v7UxVxb$kGyUtrRtdjhj$AFrpVmTlc$sMsshM6yOVXDTjxaqh1wlz4d" +
		"s#u9vtcz8nDeRNzU7rQVUC8Z#tmRt8TQVxtCh$1K6kSI5dxfgSxiM9IneQ8a5#4y0Z$$79W" +
		"3nE4jdHFOAJGGz3LzhnfUSCaWpHaons1FuKUX6$DvfIk3JCvNnEXW89Cge07XcMJswL3BCn" +
		"lkp02$yxSovyPfXB9iWcFNB96Y2Ft5308qCC$XiMP619bT1lFtJzA1zdQ5CDsj9dE$IjOBv" +
		"um5CPSShWzd07q16S03g1u$57qPd#EjFsH70Iung69iXN1r3cAmoIv9WUy45m5amQedPrlY" +
		"YyD5fdmUYl0S1K2fa=");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};
 
	static class Events extends beaver.Parser.Events {
		public void syntaxError(Symbol token) {
			System.err.format("*** Erreur de syntaxe en ligne %d, colonne %d. Token inattendu: %s\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()),
				Terminals.NAMES[token.getId()]);
		}
	}
	
	public void semanticError(String msg, Symbol token) {
			System.err.format("*** " + msg + " ligne %d, colonne %d\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()));
		}
		
	private Environment typeEnvironment = new Environment("types");
	private Environment procedureEnvironment = new Environment("procedures");
	private StackEnvironment stackEnvironment = new StackEnvironment("local variables stack");
	private String type_declaration_name;

	private final Action[] actions;

	public ParserExpr() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] program = push_stack type_declaration_part variable_declaration_part procedure_definition_part BEGIN statement_list.l END pop_stack
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 6];
					final Node l = (Node) _symbol_l.value;
					 return l;
				}
			},
			new Action() {	// [1] push_stack = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					stackEnvironment.push_stack();return new Symbol(0);
				}
			},
			new Action() {	// [2] pop_stack = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					stackEnvironment.pop_stack();return new Symbol(0);
				}
			},
			Action.NONE,  	// [3] type_declaration_part = 
			RETURN2,	// [4] type_declaration_part = TYPE type_declaration_list; returns 'type_declaration_list' although none is marked
			new Action() {	// [5] type_declaration_list = type_declaration_list.list type_declaration.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final TypeList list = (TypeList) _symbol_list.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Type t = (Type) _symbol_t.value;
					 list.add(t); return list;
				}
			},
			new Action() {	// [6] type_declaration_list = type_declaration.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					 TypeList list = new TypeList(t);  return list;
				}
			},
			new Action() {	// [7] type_declaration = type_declaration_head.name EQ type.t SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final TypeNamed name = (TypeNamed) _symbol_name.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					
		if(!t.equals(new TypeInt()) && !t.equals(new TypeBoolean()) 
				&& !t.equals(new TypeString())) {
				if(t instanceof TypeNamed) {
					if(typeEnvironment.getVariableValue(((TypeNamed)t).get_name())==null) {
						semanticError("Error : Named type assigned doesn't exist " + name + ": " + t,t);
						System.err.println("ERROR :Named type assigned doesn't exist  " + name + ": " + t);
						Main.add_error_type(new String("ERROR Type declaration : Named type assigned doesn't exist  "+ name + ": " + t ));
					}
				}
		}
		typeEnvironment.putVariable(name.get_name(),t);
		return new TypeFeature(name.get_name(),t);
				}
			},
			new Action() {	// [8] type_declaration_head = IDENTIFIER.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					 return new TypeNamed(name);
				}
			},
			Action.RETURN,	// [9] type = simple_type
			Action.RETURN,	// [10] type = named_type
			Action.RETURN,	// [11] type = index_type
			Action.RETURN,	// [12] type = array_type
			Action.RETURN,	// [13] type = pointer_type
			Action.RETURN,	// [14] type = structure_type
			new Action() {	// [15] simple_type = STR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeString();
				}
			},
			new Action() {	// [16] simple_type = INT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeInt();
				}
			},
			new Action() {	// [17] simple_type = BOOL
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeBoolean();
				}
			},
			new Action() {	// [18] named_type = IDENTIFIER.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					 return new TypeNamed(name);
				}
			},
			Action.RETURN,	// [19] index_type = enumerated_type
			Action.RETURN,	// [20] index_type = subrange_type
			new Action() {	// [21] enumerated_type = init_enumerated_type LPAR identifier_list.t_list RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t_list = _symbols[offset + 3];
					final IdentifierList t_list = (IdentifierList) _symbol_t_list.value;
					 
			Iterator<String> it = t_list.iterator();
			int i = 0;
			while(it.hasNext()) {
			String x =  it.next();
			typeEnvironment.put_enum_value(x,i);
			stackEnvironment.putVariable(x,new TypeInt(i));
			i++;
			}
			//typeEnvironment.put_enum_value(t_list.first(),0);
			//typeEnvironment.put_enum_value(t_list.last(),t_list.size()-1);
			return new TypeEnumRange(new TypeItemEnum(0,t_list.first()),new TypeItemEnum(t_list.size()-1,t_list.last()));
				}
			},
			new Action() {	// [22] init_enumerated_type = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
						return new TypeEnumRange();
				}
			},
			new Action() {	// [23] subrange_type = INTEGER_LIT.min DOUBLE_DOT INTEGER_LIT.max
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_min = _symbols[offset + 1];
					final Integer min = (Integer) _symbol_min.value;
					final Symbol _symbol_max = _symbols[offset + 3];
					final Integer max = (Integer) _symbol_max.value;
					 
		if(min > max) {
			Main.add_error_type(new String("ERROR TypeArrayRange : range not valid" + min + " > " + max));
		}
		return new TypeArrayRange(new TypeInt(min), new TypeInt(max));
				}
			},
			new Action() {	// [24] subrange_type = IDENTIFIER.min DOUBLE_DOT IDENTIFIER.max
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_min = _symbols[offset + 1];
					final String min = (String) _symbol_min.value;
					final Symbol _symbol_max = _symbols[offset + 3];
					final String max = (String) _symbol_max.value;
					 
		int v_min = typeEnvironment.get_enum_value(min);
		int v_max = typeEnvironment.get_enum_value(max);
		if(v_min > v_max) {
			Main.add_error_type(new String("ERROR TypeArrayRange : range not valid " + v_min + " > " + v_max));
		}
		return new TypeArrayRange(new TypeInt(v_min), new TypeInt(v_max));
				}
			},
			new Action() {	// [25] array_type = ARRAY LBRACKET range_type.t1 RBRACKET OF type.t2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t1 = _symbols[offset + 3];
					final Type t1 = (Type) _symbol_t1.value;
					final Symbol _symbol_t2 = _symbols[offset + 6];
					final Type t2 = (Type) _symbol_t2.value;
					 return new TypeArray(t1,t2);
				}
			},
			Action.RETURN,	// [26] range_type = enumerated_type
			Action.RETURN,	// [27] range_type = subrange_type
			Action.RETURN,	// [28] range_type = named_type
			new Action() {	// [29] pointer_type = CIRCUMFLEX type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final Type t = (Type) _symbol_t.value;
					 return new TypePointer(t);
				}
			},
			new Action() {	// [30] structure_type = STRUCT LCURLY_BRACKET feature_list_type.t RCURLY_BRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 3];
					final TypeFeatureList t = (TypeFeatureList) _symbol_t.value;
					 return new TypeStruct(t);
				}
			},
			new Action() {	// [31] feature_list_type = feature_list_type.list feature_type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final TypeFeatureList list = (TypeFeatureList) _symbol_list.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeFeature t = (TypeFeature) _symbol_t.value;
					 list.add(t); return list;
				}
			},
			new Action() {	// [32] feature_list_type = feature_type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final TypeFeature t = (TypeFeature) _symbol_t.value;
					 TypeFeatureList list = new TypeFeatureList(); list.add(t); return list;
				}
			},
			new Action() {	// [33] feature_type = IDENTIFIER.id COLON type.t SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					 return new TypeFeature(id, t);
				}
			},
			Action.NONE,  	// [34] variable_declaration_part = 
			RETURN2,	// [35] variable_declaration_part = VAR variable_declaration_list; returns 'variable_declaration_list' although none is marked
			new Action() {	// [36] variable_declaration_list = variable_declaration_list.list variable_declaration.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final NodeList list = (NodeList) _symbol_list.value;
					final Symbol _symbol_name = _symbols[offset + 2];
					final NodeList name = (NodeList) _symbol_name.value;
					 list.add(name); return list;
				}
			},
			new Action() {	// [37] variable_declaration_list = variable_declaration.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final NodeList name = (NodeList) _symbol_name.value;
					 NodeList list = new NodeList(); list.add(name); return list;
				}
			},
			new Action() {	// [38] variable_declaration = identifier_list.list COLON type.t SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final IdentifierList list = (IdentifierList) _symbol_list.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					 
		NodeList list_2 = new NodeList();
		Iterator<String> it = list.iterator();
		while(it.hasNext()) {
			String x =  it.next();
			list_2.add(new NodeId(x,t));
			stackEnvironment.putVariable(x,t);
		}
		return list_2;
				}
			},
			new Action() {	// [39] identifier_list = identifier_list.list COMMA IDENTIFIER.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final IdentifierList list = (IdentifierList) _symbol_list.value;
					final Symbol _symbol_name = _symbols[offset + 3];
					final String name = (String) _symbol_name.value;
					 list.add(name); System.err.println(list.toString()); return list;
				}
			},
			new Action() {	// [40] identifier_list = IDENTIFIER.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					 IdentifierList list = new IdentifierList(); list.add(name); return list;
				}
			},
			Action.NONE,  	// [41] procedure_definition_part = 
			Action.RETURN,	// [42] procedure_definition_part = procedure_definition_list
			new Action() {	// [43] procedure_definition_list = procedure_definition_list.list procedure_definition.func
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final NodeList list = (NodeList) _symbol_list.value;
					final Symbol _symbol_func = _symbols[offset + 2];
					final Node func = (Node) _symbol_func.value;
					 list.add(func); return list;
				}
			},
			new Action() {	// [44] procedure_definition_list = procedure_definition.func
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_func = _symbols[offset + 1];
					final Node func = (Node) _symbol_func.value;
					 NodeList list = new NodeList(); list.add(func); return list;
				}
			},
			new Action() {	// [45] procedure_definition = procedure_definition_head.s block
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol s = _symbols[offset + 1];
					
		NodeCallFct sa = (NodeCallFct)s;
		TypeFunct t = (TypeFunct) sa.getTypeFUNC();
		TypeFunct t2 = (TypeFunct) procedureEnvironment.getFunction(sa.getName());
		if(t2.getDefined()==false)
			t.setDefined(true);
		else {
			semanticError(" function already defined",s);
			System.err.println("ERROR :function already defined" + sa );
			Main.add_error_type(new String("ERROR NodeCallFct : function already defined" + sa ));
			
		}
		sa.setTypeFUNC(t);
		System.out.println("COUCOU" + sa.getTypeFUNC() );
		procedureEnvironment.putFunction(sa.getName(),sa.getTypeFUNC());
		
		return sa;
				}
			},
			RETURN2,	// [46] procedure_definition = procedure_definition_head SEMI; returns 'SEMI' although none is marked
			Action.RETURN,	// [47] procedure_definition_head = procedure_head
			new Action() {	// [48] procedure_head = PROCEDURE IDENTIFIER.func LPAR argt_part.list RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_func = _symbols[offset + 2];
					final String func = (String) _symbol_func.value;
					final Symbol _symbol_list = _symbols[offset + 4];
					final NodeList list = (NodeList) _symbol_list.value;
					 
		
		TypeTuple lionel = new TypeTuple();
		Iterator<Node> it = list.iterator();
		while(it.hasNext()) {
			NodeId x = (NodeId) it.next();		
			lionel.add( new TypeFeature(func,x.getType()));
		}

		TypeFunct lionel_le_boss = new TypeFunct(func, lionel, new TypeVoid());
		procedureEnvironment.putFunction(func,lionel_le_boss);

		return new NodeCallFct(func,new TypeFunct(func, lionel, new TypeVoid()), list);
				}
			},
			new Action() {	// [49] procedure_head = FUNCTION IDENTIFIER.func LPAR argt_part.list RPAR COLON type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_func = _symbols[offset + 2];
					final String func = (String) _symbol_func.value;
					final Symbol _symbol_list = _symbols[offset + 4];
					final NodeList list = (NodeList) _symbol_list.value;
					final Symbol _symbol_t = _symbols[offset + 7];
					final Type t = (Type) _symbol_t.value;
					 
		
		TypeTuple lionel = new TypeTuple();
		Iterator<Node> it = list.iterator();
		while(it.hasNext()) {
			NodeId x = (NodeId) it.next();		
			lionel.add( new TypeFeature(func,x.getType()));
		}

		TypeFunct lionel_le_boss = new TypeFunct(func, lionel, t);
		procedureEnvironment.putFunction(func,lionel_le_boss);

		return new NodeCallFct(func,new TypeFunct(func, lionel, t), list);
				}
			},
			Action.NONE,  	// [50] argt_part = 
			Action.RETURN,	// [51] argt_part = argt_list
			new Action() {	// [52] argt_list = argt_list.list COMMA argt.arg
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final NodeList list = (NodeList) _symbol_list.value;
					final Symbol _symbol_arg = _symbols[offset + 3];
					final Node arg = (Node) _symbol_arg.value;
					 list.add(arg); return list;
				}
			},
			new Action() {	// [53] argt_list = argt.arg
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_arg = _symbols[offset + 1];
					final Node arg = (Node) _symbol_arg.value;
					 NodeList list = new NodeList(); list.add(arg); return list;
				}
			},
			new Action() {	// [54] argt = IDENTIFIER.name COLON type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					 return new NodeId(name, t);
				}
			},
			new Action() {	// [55] block = push_stack variable_declaration_part BEGIN statement_list.l END pop_stack
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 4];
					final Node l = (Node) _symbol_l.value;
					return l;
				}
			},
			new Action() {	// [56] statement_list = statement_list.list statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final Node list = (Node) _symbol_list.value;
					final Symbol _symbol_stm = _symbols[offset + 2];
					final Node stm = (Node) _symbol_stm.value;
					 list.add(stm); return list;
				}
			},
			new Action() {	// [57] statement_list = statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_stm = _symbols[offset + 1];
					final Node stm = (Node) _symbol_stm.value;
					 NodeList list = new NodeList(); list.add(stm); System.out.println(list.toString()); return list;
				}
			},
			Action.RETURN,	// [58] statement = simple_statement
			Action.RETURN,	// [59] statement = structured_statement
			Action.RETURN,	// [60] simple_statement = assignment_statement
			Action.RETURN,	// [61] simple_statement = procedure_statement
			Action.RETURN,	// [62] simple_statement = new_statement
			Action.RETURN,	// [63] simple_statement = dispose_statement
			Action.RETURN,	// [64] simple_statement = println_statement
			Action.RETURN,	// [65] simple_statement = readln_statement
			Action.RETURN,	// [66] simple_statement = return_statement
			new Action() {	// [67] assignment_statement = variable_access.stm EQ expression.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_stm = _symbols[offset + 1];
					final NodeExp stm = (NodeExp) _symbol_stm.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 
		
		if(stm.getType()!=null && e.getType()!=null && !stm.getType().equals(e.getType())) {
			semanticError("Type error in affectation", e);
			System.err.println(new String("ERROR  : Type error in affectation " + stm.getType() + "  : " + e.getType()));
			Main.add_error_type(new String("ERROR NodeAssign: Type error in affectation " + stm.getType() + "  : " + e.getType()));
		}
		return new NodeAssign(stm, e);
				}
			},
			new Action() {	// [68] procedure_statement = procedure_expression.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final Node e = (Node) _symbol_e.value;
					return e;
				}
			},
			new Action() {	// [69] procedure_expression = IDENTIFIER.func LPAR expression_part.list RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_func = _symbols[offset + 1];
					final String func = (String) _symbol_func.value;
					final Symbol _symbol_list = _symbols[offset + 3];
					final NodeList list = (NodeList) _symbol_list.value;
					 	
		TypeFunct lionel_le_boss = (TypeFunct)procedureEnvironment.getFunction(func);
		System.out.println("Etape 126 : " + lionel_le_boss);
		System.out.println("Etape 127 : " + list);
		//Case Nb params differents
		if(lionel_le_boss.getParams().size() != list.size()) {
			
			semanticError("Type error in calling expression",list);
			System.err.println("ERROR : Type error in calling expression <NB_PARAM>" + lionel_le_boss + "  : " + list);
			Main.add_error_type(new String("ERROR NodeCallFct : Type error in calling expression <NB_PARAM>" + lionel_le_boss + "  : " + list));
		}
		//Prepare to test the type of parameters
		Iterator<Node> l = list.iterator();
		Iterator <Type> t = lionel_le_boss.getParams().iterator();
		while(l.hasNext() && t.hasNext()) {
			NodeExp n = (NodeExp) l.next();
			TypeFeature m = (TypeFeature) t.next();
			//Type Parameters different
			if(m.get(0)!=null && n.getType()!= null && !n.getType().equals(m.get(0))) {
				semanticError(" Type error in calling expression",list);
				System.err.println("ERROR : Type error in calling expression <BAD TYPES PARAMS>" + lionel_le_boss + "  : " + list);
				Main.add_error_type(new String("ERROR NodeCallFct : Type error in calling expression <BAD TYPES PARAMS>" + lionel_le_boss + "  : " + list));
			}
		}
		
		return new NodeCallFct(func, 
				lionel_le_boss, list);
				}
			},
			Action.NONE,  	// [70] expression_part = 
			Action.RETURN,	// [71] expression_part = expression_list
			new Action() {	// [72] expression_list = expression_list.list COMMA expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final NodeList list = (NodeList) _symbol_list.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 list.add(e); return list;
				}
			},
			new Action() {	// [73] expression_list = expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 NodeList list = new NodeList(); list.add(e); return list;
				}
			},
			new Action() {	// [74] new_statement = NEW variable_access.stm SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_stm = _symbols[offset + 2];
					final NodeExp stm = (NodeExp) _symbol_stm.value;
					return new NodeNew(stm);
				}
			},
			new Action() {	// [75] dispose_statement = DISPOSE variable_access.stm SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_stm = _symbols[offset + 2];
					final NodeExp stm = (NodeExp) _symbol_stm.value;
					 return new NodeDispose(stm);
				}
			},
			new Action() {	// [76] println_statement = PRINTLN expression.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 
		return new NodeCallFct("println",
			new TypeFunct("println",new TypeTuple(new TypeFeature("println",e.getType())),
					new TypeVoid()), new NodeList(e));
				}
			},
			new Action() {	// [77] readln_statement = READLN.func expression.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol func = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 
		return new NodeCallFct("readln", 
			new TypeFunct("readln",new TypeTuple(new TypeFeature("readln",e.getType())),
					new TypeVoid()), new NodeList(e));
				}
			},
			new Action() {	// [78] return_statement = RETURN expression.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return new NodeReturn(e);
				}
			},
			Action.RETURN,	// [79] structured_statement = block
			Action.RETURN,	// [80] structured_statement = if_statement
			Action.RETURN,	// [81] structured_statement = while_statement
			Action.RETURN,	// [82] structured_statement = switch_statement
			new Action() {	// [83] if_statement = IF expression.e THEN statement.stm1 ELSE statement.stm2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					final Symbol _symbol_stm1 = _symbols[offset + 4];
					final Node stm1 = (Node) _symbol_stm1.value;
					final Symbol _symbol_stm2 = _symbols[offset + 6];
					final Node stm2 = (Node) _symbol_stm2.value;
					 return new NodeIf(e, stm1, stm2);
				}
			},
			new Action() {	// [84] if_statement = IF expression.e THEN statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					final Symbol _symbol_stm = _symbols[offset + 4];
					final Node stm = (Node) _symbol_stm.value;
					 return new NodeIf(e, stm);
				}
			},
			new Action() {	// [85] while_statement = WHILE expression.e DO statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					final Symbol _symbol_stm = _symbols[offset + 4];
					final Node stm = (Node) _symbol_stm.value;
					 return new NodeWhile(e, stm);
				}
			},
			new Action() {	// [86] switch_statement = SWITCH expression.e BEGIN case_statement_list.stm END
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					final Symbol _symbol_stm = _symbols[offset + 4];
					final NodeCaseList stm = (NodeCaseList) _symbol_stm.value;
					 return new NodeSwitch(e, stm);
				}
			},
			new Action() {	// [87] case_statement_list = case_statement_list.list case_statement.case1 case_default.case2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final NodeCaseList list = (NodeCaseList) _symbol_list.value;
					final Symbol _symbol_case1 = _symbols[offset + 2];
					final NodeList case1 = (NodeList) _symbol_case1.value;
					final Symbol _symbol_case2 = _symbols[offset + 3];
					final NodeCase case2 = (NodeCase) _symbol_case2.value;
					 list.add(case1);if(case2!=null)list.add(case2); return list;
				}
			},
			new Action() {	// [88] case_statement_list = case_statement.case1 case_default.case2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_case1 = _symbols[offset + 1];
					final NodeList case1 = (NodeList) _symbol_case1.value;
					final Symbol _symbol_case2 = _symbols[offset + 2];
					final NodeCase case2 = (NodeCase) _symbol_case2.value;
					 
		NodeCaseList list = new NodeCaseList(); list.add(case1); if(case2!=null)list.add(case2);															
		return list;
				}
			},
			new Action() {	// [89] case_statement = CASE identifier_list.list COLON statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 2];
					final IdentifierList list = (IdentifierList) _symbol_list.value;
					final Symbol _symbol_stm = _symbols[offset + 4];
					final Node stm = (Node) _symbol_stm.value;
					 
		NodeList list_2 = new NodeList();
		Iterator<String> it = list.iterator();
		while(it.hasNext()) {
			String x =  it.next();
			list_2.add(new NodeCase(x,stm));
		}
		return list_2;
				}
			},
			Action.NONE,  	// [90] case_default = 
			new Action() {	// [91] case_default = DEFAULT COLON statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_stm = _symbols[offset + 3];
					final Node stm = (Node) _symbol_stm.value;
					 System.out.println("coucou");return new NodeCase(stm);
				}
			},
			new Action() {	// [92] variable_access = IDENTIFIER.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					  
		return new NodeId(name, stackEnvironment.getVariableValue(name));
				}
			},
			new Action() {	// [93] variable_access = variable_access.e1 LBRACKET expression.e2 RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 
		boolean is_id = false;
		NodeId id = (NodeId) e1;
		Node id2 = (Node) e2;
		if(e2 instanceof NodeId) {
				is_id = true; 
		}
		TypeArray array = (TypeArray) id.getType(); 
		Type type = null;
		if(is_id) {
			NodeId id3 = (NodeId) id2;
			type = (Type)id3.getType();
		if(type==null || array.getRangeOREnum().getFirst().equals(type)) {
			semanticError(" Type error in array access ",e1);
			System.err.println("ERROR :Type error in array access " + id +" : " + id3 );
			Main.add_error_type(new String("ERROR NodeArrayAccess : Type error in array access " + id +" : " + new NodeId("Error",new TypeInt())));
			return new NodeArrayAccess(e1, new NodeId("Error",new TypeInt())) ;
		}
		}
		return new NodeArrayAccess(e1, e2) ;
				}
			},
			new Action() {	// [94] variable_access = expression.e CIRCUMFLEX
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return new NodePtrAccess(e);
				}
			},
			new Action() {	// [95] expression = expression.e1 PLUS expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("+", e1, e2);
				}
			},
			new Action() {	// [96] expression = expression.e1 MINUS expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("-", e1, e2);
				}
			},
			new Action() {	// [97] expression = MINUS expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return new NodeOp("-", e);
				}
			},
			new Action() {	// [98] expression = expression.e1 TIMES expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("*", e1, e2);
				}
			},
			new Action() {	// [99] expression = expression.e1 DIV expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("/", e1, e2);
				}
			},
			new Action() {	// [100] expression = expression.e1 AND expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("&&", e1, e2);
				}
			},
			new Action() {	// [101] expression = expression.e1 OR expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("||", e1, e2);
				}
			},
			new Action() {	// [102] expression = NOT expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return new NodeOp("!", e);
				}
			},
			new Action() {	// [103] expression = expression.e1 INFERIOR expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("<", e1, e2);
				}
			},
			new Action() {	// [104] expression = expression.e1 INFERIOR_EQ expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("<=", e1, e2);
				}
			},
			new Action() {	// [105] expression = expression.e1 SUPERIOR expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp(">", e1, e2);
				}
			},
			new Action() {	// [106] expression = expression.e1 SUPERIOR_EQ expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp(">=", e1, e2);
				}
			},
			new Action() {	// [107] expression = expression.e1 EQUALS expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("==", e1, e2);
				}
			},
			new Action() {	// [108] expression = expression.e1 DIFF expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("!=", e1, e2);
				}
			},
			new Action() {	// [109] expression = LPAR expression.e RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return e;
				}
			},
			Action.RETURN,	// [110] expression = procedure_expression
			Action.RETURN,	// [111] expression = variable_access
			Action.RETURN,	// [112] expression = literal
			new Action() {	// [113] literal = INTEGER_LIT.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final Integer e = (Integer) _symbol_e.value;
					 return new NodeLiteral(new TypeInt(e), e);
				}
			},
			new Action() {	// [114] literal = STRING_LIT.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final String e = (String) _symbol_e.value;
					 return new NodeLiteral(new TypeString(), e);
				}
			},
			new Action() {	// [115] literal = TRUE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NodeLiteral(new TypeBoolean(), true);
				}
			},
			new Action() {	// [116] literal = FALSE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NodeLiteral(new TypeBoolean(), false);
				}
			},
			new Action() {	// [117] literal = NULL
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NodeLiteral(new TypePointer(), null);
				}
			}
		};

 
	report = new Events();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
