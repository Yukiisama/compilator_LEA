

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "Parser.grammar".
 */
public class Parser extends beaver.Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjM7TyL4KG$jxTAHOie2O45L7HX0J1JeqG4AaY10W4GZMIWBqWAYhO6wYq03OWAaK11HG" +
		"K4WH444MAlIk8MB0Nn3f#Rs$kiidTlJpDB$$nxlUzcPtzTcRsbTrv1uJ#GZQIS2vQOn1guo" +
		"diZmDm86hY81oCGt0eQk4m78uZq0QdeIawu0nqH2TqHXSSWsEnRwnTjc4sHY60yt4npaDFv" +
		"20NUHYE8haF6sGb#xgY9LemOeqgnHuID$RPzDys9dQiXw5nR5VYINe8qiC#CHxiJFVx3vd6" +
		"o$4PZ99j8epJglhYqFTeP37QJCP9zemph4fnsk4wJ6USmOnphMUSmYh5wOQfA62SAnZdAiy" +
		"u5rKfpY8inaZ6AMQSOiyuLrSfpY0imGsCSoVZtEKPPq72E4UZZhvBup45zw6kUJEEnF4u0Q" +
		"beY0oSX2OuXRmK7ANC#p7TWpSD3w0vwYat4IzsDWzX5HxX#FewyZainraUSVhYE6KMOvO7h" +
		"pyQAEynFEx16uWJbJSVIpruQM6MV2LVoli9UUdgwsWqKcqrdiK52VcNoXVaDbRkCZoF2pro" +
		"E5bvfIZ1IW$UgSfRWnVnaWVlTEMjmqR#4lFELDwhU0sRFNZDb1S#4lCoVVBEySdBHdUVl5w" +
		"#U7rynktdY#VddTvhiIrty6e#Z4Sn87fz9s8CxiOzk1utOYnkmisu9ShAjrWZL1#7oRWLj#" +
		"5s7JV16eVeo39MnF#aEFulKPztaEMs8QKn$X#iuBzz0lylbFE$qB1MOHxcOAx9$pAivVhN8" +
		"yR$UclSlHpPAe7$JHRlPUv7byjxt6Lx8#JMA7W2C$0qIcMhDR8Krs0B$Rc7krRDDDeAlA9F" +
		"DUHrM0TRpNarMd949jVfrhnxMQoRsh5#Qi$tjKFq7Zgiv8ACkmzhlHgc8d7teJvnx4dSkUg" +
		"m2gZBT#SelbNr#1xLvvkKpxlPZFjFdMZ4Z6g8NK3$msDYnp8pujXEvjkTn5pgy5pHm$$DD5" +
		"wEoIO2U4whnZXfNBM2Z9FEE8shCKuAdqU7SP8Ofryrnadc$dOcemnY7ASQu$HdtPNAE4urn" +
		"t4z93DEaoh42KHvQLnr6yPKXxMrFWmmKeHvAgCbvkLoxYbHRY9UlBkJm#UWB9y1hCJyvUDu" +
		"vbF6Qy9uVdYfdluYh8Ry9INaHLXb$4RS$Sz8o4#Yjp9ka5UmgOyS75wpL5yyrsFblDHAhcM" +
		"4rvVhGNBbF377Nbx2PtwlfH8BhwPhYLvVNjkk$9hjnY$SxgoAilcTsoikA$Aa7iVgkm7hxn" +
		"DZnv4N6Ld6yk7Vl25iqvfIcN$kdJxySqToMJdXFfD$eLd$ahtyyqlVuQfTkNztFyhW2jER$" +
		"eQO6gKVCn$6qNR#3hzA#oBDFC7kMfLkj7GC5JsG8jR1iS3MiMu5AF8FHNqWK41v5N4vKPie" +
		"SVl$3tYi9V80vqFBDfgeHImapYEsX#rEaihEpA6OyaRAfPIBALct1fXhu6CWE8do9yg7Y7s" +
		"9nucw1Fq56nFBmdw2guYsn0Rw#C6ANqGRgzz0oBBj8kgHLoFS3kMJym6H4tzUmH7aPgg#W$" +
		"mYrPbpy5ksLsfxD#CqK5seDrF$#r7lglCzc2VE0TsrZzScC9ZAU#pZ$N0EKZld6E1zSRAqV" +
		"JpRuwZqfZwdB3SdbpYV6AdjUuZnEizrv3PYEygl3EHE85PNiAsWdr6K9OJhixNcbAVzYuWz" +
		"nB7Mc6tilvGvrmot0$os2wrMlKqPBt02qSDgPnCzYUkqdKLVyyhd4ohL#HLRumg9sUpZVGn" +
		"CK1wVnq29zazZUvp5tq9ifcqxvN9Y9VKPLl$dn4xLDxAFSm$iiFFWE$GgHHVsZTJsUef#Vg" +
		"zr8d2#iokqLwZSgl8xpIkeCbbbXigpLFPGcQFo8fLZLKvMELTbv5fjYSsf$Dp3jXZE7d$p2" +
		"zQiqAvlwQTRUaTBtrD#37SSuDwm7ZfGRMjKxbPxhR1qqhNTKYNN2VmUcvSpKFl7yBJHYhtB" +
		"pxmgdtSerz8ZQy#H4HkV7pwJpi8AOvfQ#SNS5$#ndOaLsYUf71E7kwbyEr1evTCbphowMNg" +
		"1fO$ds5bMUtJvSTZAMVyZsn0zPAEy8XlaPLalw#GbMIiloXfvLfwH9R9OYWnZjSpXcM#wS1" +
		"KLzvySxXuoYvX9F48yJ72ta0U91uZfn6F433D#canLJtDbYimpsWlcN2AJPP9Cb0bolwmWQ" +
		"nLjHRBSz1N9yqO#PyxBp7cfvloQIgw2yhJgJqLdj50MgFOayQbyegsFv7VP8x$9RlbLVf6V" +
		"vIVvKNwWVPTyBzzPL#HhOgVgdyiErRQRC$SU#L0#CFetyfdsVMpEJyXyTtsITuctvQselpV" +
		"DUOivRvBDi0vvGzxX#M$vIzj$o9yKbs44gxl1r0QpsXjguB3k274$T#AYkuMkH0$5kQnykY" +
		"cowTEjXYBeIR#zw3EVCf$jNEgPZ9d9zWK63ckW4FU$eFdlOGZxXb0EOvzR5$MdT977bI6Fj" +
		"UW0zW#WVI3v0yrNLv1VrI7q8SVz5wcreeq7sfBVZloMbCFfRpXj1VHJG7asPNlY7A83qP78" +
		"ejr69uxhn7bsfkp2l0hfgz3KZY5JFxQWte9w2$Cz4bJOkfVDXXD5gpYuy5$IuIVQ");

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN6 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 6];
		}
	};
 
	static class Events extends beaver.Parser.events {
		public void syntaxError(Symbol token) {
			System.err.format("*** Erreur de syntaxe en ligne %d, colonne %d. Token inattendu: %s\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()),
				Terminals.NAMES[token.getId()]);
		}
	}
	
	public void semanticError(String msg, Symbol token) {
			Systemrr.format("*** " + msg + " ligne %d, colonne %d\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()));
		}
		
	private Environment typeEnvironment = new Environment("types");
	private Environment procedureEnvironment = new Environment("procedures");
	private StackEnvironment stackEnvironment = new StackEnvironment("local variables stack");
	private String type_declaration_name;

	private final Action[] actions;

	public Parser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			RETURN5,	// [0] program = type_declaration_part variable_declaration_part procedure_definition_part BEGIN statement_list.stm END
			Action.NONE,  	// [1] type_declaration_part = 
			RETURN2,	// [2] type_declaration_part = TYPE type_declaration_list; returns 'type_declaration_list' although none is marked
			new Action() {	// [3] type_declaration_list = type_declaration_list type_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [4] type_declaration_list = type_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN4,	// [5] type_declaration = IDENTIFIER EQ type SEMI; returns 'SEMI' although none is marked
			Action.RETURN,	// [6] type = simple_type
			Action.RETURN,	// [7] type = named_type
			Action.RETURN,	// [8] type = index_type
			Action.RETURN,	// [9] type = array_type
			Action.RETURN,	// [10] type = pointer_type
			Action.RETURN,	// [11] type = structure_type
			Action.RETURN,	// [12] simple_type = STR
			Action.RETURN,	// [13] simple_type = INT
			Action.RETURN,	// [14] simple_type = BOOL
			Action.RETURN,	// [15] named_type = IDENTIFIER
			Action.RETURN,	// [16] index_type = enumerated_type
			Action.RETURN,	// [17] index_type = subrange_type
			RETURN3,	// [18] enumerated_type = LPAR identifier_list RPAR; returns 'RPAR' although none is marked
			RETURN3,	// [19] subrange_type = INTEGER DOUBLE_DOT INTEGER; returns 'INTEGER' although none is marked
			RETURN3,	// [20] subrange_type = IDENTIFIER DOUBLE_DOT IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN6,	// [21] array_type = ARRAY LBRACKET range_type RBRACKET OF type; returns 'type' although none is marked
			Action.RETURN,	// [22] range_type = enumerated_type
			Action.RETURN,	// [23] range_type = subrange_type
			Action.RETURN,	// [24] range_type = named_type
			RETURN2,	// [25] pointer_type = CIRCUMFLEX type; returns 'type' although none is marked
			RETURN4,	// [26] structure_type = STRUCT LCURLY_BRACKET feature_list_type RCURLY_BRACKET; returns 'RCURLY_BRACKET' although none is marked
			new Action() {	// [27] feature_list_type = feature_list_type feature_type
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [28] feature_list_type = feature_type
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN4,	// [29] feature_type = IDENTIFIER COLON type SEMI; returns 'SEMI' although none is marked
			Action.NONE,  	// [30] variable_declaration_part = 
			RETURN2,	// [31] variable_declaration_part = VAR variable_declaration_list; returns 'variable_declaration_list' although none is marked
			new Action() {	// [32] variable_declaration_list = variable_declaration_list variable_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [33] variable_declaration_list = variable_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN4,	// [34] variable_declaration = identifier_list COLON type SEMI; returns 'SEMI' although none is marked
			new Action() {	// [35] identifier_list = identifier_list COMMA IDENTIFIER
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [36] identifier_list = IDENTIFIER
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			Action.NONE,  	// [37] procedure_definition_part = 
			Action.RETURN,	// [38] procedure_definition_part = procedure_definition_list
			new Action() {	// [39] procedure_definition_list = procedure_definition_list procedure_definition
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [40] procedure_definition_list = procedure_definition
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN2,	// [41] procedure_definition = procedure_definition_head block; returns 'block' although none is marked
			RETURN2,	// [42] procedure_definition = procedure_definition_head SEMI; returns 'SEMI' although none is marked
			RETURN5,	// [43] procedure_definition_head = PROCEDURE IDENTIFIER LPAR argt_part RPAR; returns 'RPAR' although none is marked
			RETURN4,	// [44] procedure_definition_head = FUNCTION IDENTIFIER LPAR argt_part.args RPAR COLON type
			Action.NONE,  	// [45] argt_part = 
			Action.RETURN,	// [46] argt_part = argt_list
			new Action() {	// [47] argt_list = argt_list COMMA argt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [48] argt_list = argt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN3,	// [49] argt = IDENTIFIER COLON type; returns 'type' although none is marked
			RETURN4,	// [50] block = variable_declaration_part BEGIN statement_list END; returns 'END' although none is marked
			new Action() {	// [51] statement_list = statement_list statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [52] statement_list = statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [53] statement = simple_statement
			Action.RETURN,	// [54] statement = structured_statement
			Action.RETURN,	// [55] simple_statement = assignment_statement
			Action.RETURN,	// [56] simple_statement = procedure_statement
			Action.RETURN,	// [57] simple_statement = new_statement
			Action.RETURN,	// [58] simple_statement = dispose_statement
			Action.RETURN,	// [59] simple_statement = println_statement
			Action.RETURN,	// [60] simple_statement = readln_statement
			Action.RETURN,	// [61] simple_statement = return_statement
			RETURN4,	// [62] assignment_statement = variable_access EQ expression SEMI; returns 'SEMI' although none is marked
			RETURN2,	// [63] procedure_statement = procedure_expression SEMI; returns 'SEMI' although none is marked
			RETURN4,	// [64] procedure_expression = IDENTIFIER LPAR expression_part RPAR; returns 'RPAR' although none is marked
			Action.NONE,  	// [65] expression_part = 
			Action.RETURN,	// [66] expression_part = expression_list
			new Action() {	// [67] expression_list = expression_list COMMA expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [68] expression_list = expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN3,	// [69] new_statement = NEW variable_access SEMI; returns 'SEMI' although none is marked
			RETURN3,	// [70] dispose_statement = DISPOSE variable_access SEMI; returns 'SEMI' although none is marked
			RETURN3,	// [71] println_statement = PRINTLN expression SEMI; returns 'SEMI' although none is marked
			RETURN3,	// [72] readln_statement = READLN expression SEMI; returns 'SEMI' although none is marked
			RETURN3,	// [73] return_statement = RETURN expression SEMI; returns 'SEMI' although none is marked
			Action.RETURN,	// [74] structured_statement = block
			Action.RETURN,	// [75] structured_statement = if_statement
			Action.RETURN,	// [76] structured_statement = while_statement
			Action.RETURN,	// [77] structured_statement = switch_statement
			RETURN4,	// [78] if_statement = IF expression THEN statement; returns 'statement' although none is marked
			RETURN6,	// [79] if_statement = IF expression THEN statement ELSE statement; returns 'statement' although none is marked
			RETURN4,	// [80] while_statement = WHILE expression DO statement; returns 'statement' although none is marked
			RETURN5,	// [81] switch_statement = SWITCH expression BEGIN case_statement_list END; returns 'END' although none is marked
			new Action() {	// [82] case_statement_list = case_statement_list case_statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [83] case_statement_list = case_statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN4,	// [84] case_statement = CASE IDENTIFIER COLON statement; returns 'statement' although none is marked
			RETURN3,	// [85] case_statement = DEFAULT COLON statement; returns 'statement' although none is marked
			Action.RETURN,	// [86] variable_access = IDENTIFIER
			RETURN4,	// [87] variable_access = variable_access LBRACKET expression RBRACKET; returns 'RBRACKET' although none is marked
			RETURN2,	// [88] variable_access = expression CIRCUMFLEX; returns 'CIRCUMFLEX' although none is marked
			new Action() {	// [89] expression = expression.e1 PLUS expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e1 = _symbols[offset + 1];
					final Symbol e2 = _symbols[offset + 3];
					 return new Binop(0, e1, e2);
				}
			},
			new Action() {	// [90] expression = expression.e1 MINUS expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e1 = _symbols[offset + 1];
					final Symbol e2 = _symbols[offset + 3];
					 return new Binop(1, e1, e2);
				}
			},
			new Action() {	// [91] expression = MINUS expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e = _symbols[offset + 2];
					 return new Binop(e);
				}
			},
			new Action() {	// [92] expression = expression.e1 TIMES expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e1 = _symbols[offset + 1];
					final Symbol e2 = _symbols[offset + 3];
					 return new Binop(2, e1, e2);
				}
			},
			new Action() {	// [93] expression = expression.e1 DIV expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e1 = _symbols[offset + 1];
					final Symbol e2 = _symbols[offset + 3];
					 return new Binop(3, e1, e2);
				}
			},
			new Action() {	// [94] expression = expression.e1 AND expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e1 = _symbols[offset + 1];
					final Symbol e2 = _symbols[offset + 3];
					 return new Binop(4, e1, e2);
				}
			},
			new Action() {	// [95] expression = expression.e1 OR expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e1 = _symbols[offset + 1];
					final Symbol e2 = _symbols[offset + 3];
					 return new Binop(5, e1, e2);
				}
			},
			RETURN2,	// [96] expression = NOT expression.e
			RETURN3,	// [97] expression = expression.e1 INFERIOR expression.e2; returns 'e2' although more are marked
			RETURN3,	// [98] expression = expression.e1 INFERIOR_EQ expression.e2; returns 'e2' although more are marked
			RETURN3,	// [99] expression = expression.e1 SUPERIOR expression.e2; returns 'e2' although more are marked
			RETURN3,	// [100] expression = expression.e1 SUPERIOR_EQ expression.e2; returns 'e2' although more are marked
			RETURN3,	// [101] expression = expression.e1 EQUALS expression.e2; returns 'e2' although more are marked
			RETURN3,	// [102] expression = expression.e1 DIFF expression.e2; returns 'e2' although more are marked
			new Action() {	// [103] expression = LPAR expression.e RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e = _symbols[offset + 2];
					 return e;
				}
			},
			Action.RETURN,	// [104] expression = procedure_expression
			Action.RETURN,	// [105] expression = variable_access
			Action.RETURN,	// [106] expression = literal
			Action.RETURN,	// [107] literal = INTEGER
			Action.RETURN,	// [108] literal = STRING
			Action.RETURN,	// [109] literal = TRUE
			Action.RETURN,	// [110] literal = FALSE
			Action.RETURN	// [111] literal = NULL
		};

 
	report = new MyEvents();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
