*** Fichier data/progr9.lea
*** /* **************************************************
 ************************************************** */
*** type
Stack PUSH
*** chaine
*** =
*** string
*** ;
*** entier
Enregistre chaine TypeString
*** =
*** integer
*** ;
*** booleen
Enregistre entier TypeInt_null
*** =
*** boolean
*** ;
*** named1
Enregistre booleen TypeBoolean
*** =
*** chaine
*** ;
*** //named2 = unknown; // error
*** Months
Retrouve1 chaine TypeString
Enregistre named1 TypeNamed_chaine
*** =
*** (
*** January
*** ,
*** February
*** ,
*** March
*** ,
*** April
*** ,
*** May
*** ,
*** June
*** ,
*** July
*** ,
*** August
*** ,
*** September
*** ,
*** October
*** ,
*** November
*** ,
*** December
*** )
*** ;
Enregistre January TypeItemEnum@January=0 nom :
Enregistre dans stack   January TypeItemEnum@January=0 nom :
Enregistre February TypeItemEnum@February=1 nom :
Enregistre dans stack   February TypeItemEnum@February=1 nom :
Enregistre March TypeItemEnum@March=2 nom :
Enregistre dans stack   March TypeItemEnum@March=2 nom :
Enregistre April TypeItemEnum@April=3 nom :
Enregistre dans stack   April TypeItemEnum@April=3 nom :
Enregistre May TypeItemEnum@May=4 nom :
Enregistre dans stack   May TypeItemEnum@May=4 nom :
Enregistre June TypeItemEnum@June=5 nom :
Enregistre dans stack   June TypeItemEnum@June=5 nom :
Enregistre July TypeItemEnum@July=6 nom :
Enregistre dans stack   July TypeItemEnum@July=6 nom :
Enregistre August TypeItemEnum@August=7 nom :
Enregistre dans stack   August TypeItemEnum@August=7 nom :
Enregistre September TypeItemEnum@September=8 nom :
Enregistre dans stack   September TypeItemEnum@September=8 nom :
Enregistre October TypeItemEnum@October=9 nom :
Enregistre dans stack   October TypeItemEnum@October=9 nom :
Enregistre November TypeItemEnum@November=10 nom :
Enregistre dans stack   November TypeItemEnum@November=10 nom :
Enregistre December TypeItemEnum@December=11 nom :
Enregistre dans stack   December TypeItemEnum@December=11 nom :
*** DaysOfWeek
Enregistre Months TypeEnumRange[TypeItemEnum@January=0 nom :..TypeItemEnum@December=11 nom :]_1
Enregistre January TypeItemEnum@January=0 nom :Months
Enregistre dans stack   January TypeItemEnum@January=0 nom :Months
Enregistre February TypeItemEnum@February=1 nom :Months
Enregistre dans stack   February TypeItemEnum@February=1 nom :Months
Enregistre March TypeItemEnum@March=2 nom :Months
Enregistre dans stack   March TypeItemEnum@March=2 nom :Months
Enregistre April TypeItemEnum@April=3 nom :Months
Enregistre dans stack   April TypeItemEnum@April=3 nom :Months
Enregistre May TypeItemEnum@May=4 nom :Months
Enregistre dans stack   May TypeItemEnum@May=4 nom :Months
Enregistre June TypeItemEnum@June=5 nom :Months
Enregistre dans stack   June TypeItemEnum@June=5 nom :Months
Enregistre July TypeItemEnum@July=6 nom :Months
Enregistre dans stack   July TypeItemEnum@July=6 nom :Months
Enregistre August TypeItemEnum@August=7 nom :Months
Enregistre dans stack   August TypeItemEnum@August=7 nom :Months
Enregistre September TypeItemEnum@September=8 nom :Months
Enregistre dans stack   September TypeItemEnum@September=8 nom :Months
Enregistre October TypeItemEnum@October=9 nom :Months
Enregistre dans stack   October TypeItemEnum@October=9 nom :Months
Enregistre November TypeItemEnum@November=10 nom :Months
Enregistre dans stack   November TypeItemEnum@November=10 nom :Months
Enregistre December TypeItemEnum@December=11 nom :Months
Enregistre dans stack   December TypeItemEnum@December=11 nom :Months
*** =
*** (
*** Sunday
*** ,
*** Monday
*** ,
*** Tuesday
*** ,
*** Wednesday
*** ,
*** Thursday
*** ,
*** Friday
*** ,
*** Saturday
*** )
*** ;
Enregistre Sunday TypeItemEnum@Sunday=0 nom :
Enregistre dans stack   Sunday TypeItemEnum@Sunday=0 nom :
Enregistre Monday TypeItemEnum@Monday=1 nom :
Enregistre dans stack   Monday TypeItemEnum@Monday=1 nom :
Enregistre Tuesday TypeItemEnum@Tuesday=2 nom :
Enregistre dans stack   Tuesday TypeItemEnum@Tuesday=2 nom :
Enregistre Wednesday TypeItemEnum@Wednesday=3 nom :
Enregistre dans stack   Wednesday TypeItemEnum@Wednesday=3 nom :
Enregistre Thursday TypeItemEnum@Thursday=4 nom :
Enregistre dans stack   Thursday TypeItemEnum@Thursday=4 nom :
Enregistre Friday TypeItemEnum@Friday=5 nom :
Enregistre dans stack   Friday TypeItemEnum@Friday=5 nom :
Enregistre Saturday TypeItemEnum@Saturday=6 nom :
Enregistre dans stack   Saturday TypeItemEnum@Saturday=6 nom :
*** //xxx = (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, aa, ab, ac, ad, ae, af, ag, ah); // error
*** range1
Enregistre DaysOfWeek TypeEnumRange[TypeItemEnum@Sunday=0 nom :..TypeItemEnum@Saturday=6 nom :]_3
Enregistre Sunday TypeItemEnum@Sunday=0 nom :DaysOfWeek
Enregistre dans stack   Sunday TypeItemEnum@Sunday=0 nom :DaysOfWeek
Enregistre Monday TypeItemEnum@Monday=1 nom :DaysOfWeek
Enregistre dans stack   Monday TypeItemEnum@Monday=1 nom :DaysOfWeek
Enregistre Tuesday TypeItemEnum@Tuesday=2 nom :DaysOfWeek
Enregistre dans stack   Tuesday TypeItemEnum@Tuesday=2 nom :DaysOfWeek
Enregistre Wednesday TypeItemEnum@Wednesday=3 nom :DaysOfWeek
Enregistre dans stack   Wednesday TypeItemEnum@Wednesday=3 nom :DaysOfWeek
Enregistre Thursday TypeItemEnum@Thursday=4 nom :DaysOfWeek
Enregistre dans stack   Thursday TypeItemEnum@Thursday=4 nom :DaysOfWeek
Enregistre Friday TypeItemEnum@Friday=5 nom :DaysOfWeek
Enregistre dans stack   Friday TypeItemEnum@Friday=5 nom :DaysOfWeek
Enregistre Saturday TypeItemEnum@Saturday=6 nom :DaysOfWeek
Enregistre dans stack   Saturday TypeItemEnum@Saturday=6 nom :DaysOfWeek
*** =
*** 64
*** ..
*** 81
*** ;
*** range2
Enregistre range1 TypeArrayRange[TypeInt_64..TypeInt_81]
*** =
*** Monday
*** ..
*** Friday
*** ;
Retrouve3 Monday TypeItemEnum@Monday=1 nom :DaysOfWeek
Retrouve3 Friday TypeItemEnum@Friday=5 nom :DaysOfWeek
*** //range3 = 81 .. 64; //error
*** //range4 = Friday .. Unknown; // error
*** //range5 = Friday .. Monday; // error
*** //range6 = Monday .. December; //error
*** //range7 = Friday .. Tuesday; // error "range not valid"
*** //range8 = Monday .. April; // error "incoherent range"
*** table1
Enregistre range2 TypeArrayRange[TypeInt_1..TypeInt_5]
*** =
*** array
*** [
*** 1
*** ..
*** 32
*** ]
*** of
*** integer
*** ;
*** table2
Enregistre table1 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
*** =
*** array
*** [
*** range1
*** ]
*** of
*** integer
*** ;
Retrouve1 range1 TypeArrayRange[TypeInt_64..TypeInt_81]
Retrouve1 range1 TypeArrayRange[TypeInt_64..TypeInt_81]
*** table3
Enregistre table2 TypeArray(TypeArrayRange[TypeInt_64..TypeInt_81], TypeInt_null)
*** =
*** array
*** [
*** range2
*** ]
*** of
*** integer
*** ;
Retrouve1 range2 TypeArrayRange[TypeInt_1..TypeInt_5]
Retrouve1 range2 TypeArrayRange[TypeInt_1..TypeInt_5]
*** table4
Enregistre table3 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeInt_null)
*** =
*** array
*** [
*** 1
*** ..
*** 32
*** ]
*** of
*** array
*** [
*** DaysOfWeek
*** ]
*** of
*** integer
*** ;
Retrouve1 DaysOfWeek TypeEnumRange[TypeItemEnum@Sunday=0 nom :..TypeItemEnum@Saturday=6 nom :]_3
Retrouve1 DaysOfWeek TypeEnumRange[TypeItemEnum@Sunday=0 nom :..TypeItemEnum@Saturday=6 nom :]_3
*** //table5 = array [ 1 .. 32 ] of array [ range3 ] of integer; // error "Range type expected"
*** table6
Enregistre table4 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeArray(TypeEnumRange[TypeItemEnum@Sunday=0 nom :..TypeItemEnum@Saturday=6 nom :]_3, TypeInt_null))
*** =
*** array
*** [
*** 1
*** ..
*** 32
*** ]
*** of
*** array
*** [
*** Wednesday
*** ..
*** Saturday
*** ]
Retrouve3 Wednesday TypeItemEnum@Wednesday=3 nom :DaysOfWeek
Retrouve3 Saturday TypeItemEnum@Saturday=6 nom :DaysOfWeek
*** of
*** integer
*** ;
*** ptr1
Enregistre table6 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeArray(TypeArrayRange[TypeInt_3..TypeInt_6], TypeInt_null))
*** =
*** ^
*** integer
*** ;
*** ptr2
Enregistre ptr1 TypePointer(TypeInt_null)
*** =
*** ^
*** array
*** [
*** 1
*** ..
*** 32
*** ]
*** of
*** array
*** [
*** DaysOfWeek
*** ]
*** of
*** integer
*** ;
Retrouve1 DaysOfWeek TypeEnumRange[TypeItemEnum@Sunday=0 nom :..TypeItemEnum@Saturday=6 nom :]_3
Retrouve1 DaysOfWeek TypeEnumRange[TypeItemEnum@Sunday=0 nom :..TypeItemEnum@Saturday=6 nom :]_3
*** var
Enregistre ptr2 TypePointer(TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeArray(TypeEnumRange[TypeItemEnum@Sunday=0 nom :..TypeItemEnum@Saturday=6 nom :]_3, TypeInt_null)))
*** x
*** ,
*** y
*** ,
*** z
*** :
*** integer
*** ;
*** //x : boolean; // error "Variable x yet declared"
*** b
Create class NodeList
Create class NodeId
Enregistre dans stack   x TypeInt_null
Create class NodeId
Enregistre dans stack   y TypeInt_null
Create class NodeId
Enregistre dans stack   z TypeInt_null
Create class NodeList
*** :
*** boolean
*** ;
*** z2
Create class NodeList
Create class NodeId
Enregistre dans stack   b TypeBoolean
*** :
*** array
*** [
*** 1
*** ..
*** 32
*** ]
*** of
*** integer
*** ;
*** k
Create class NodeList
Create class NodeId
Enregistre dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
*** :
*** array
*** [
*** range2
*** ]
*** of
*** integer
*** ;
Retrouve1 range2 TypeArrayRange[TypeInt_1..TypeInt_5]
Retrouve1 range2 TypeArrayRange[TypeInt_1..TypeInt_5]
*** l
Create class NodeList
Create class NodeId
Enregistre dans stack   k TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeInt_null)
*** :
*** array
*** [
*** range2
*** ]
*** of
*** boolean
*** ;
Retrouve1 range2 TypeArrayRange[TypeInt_1..TypeInt_5]
Retrouve1 range2 TypeArrayRange[TypeInt_1..TypeInt_5]
*** m2
Create class NodeList
Create class NodeId
Enregistre dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
*** :
*** array
*** [
*** Monday
*** ..
*** Thursday
*** ]
Retrouve3 Monday TypeItemEnum@Monday=1 nom :DaysOfWeek
Retrouve3 Thursday TypeItemEnum@Thursday=4 nom :DaysOfWeek
*** of
*** boolean
*** ;
*** p
Create class NodeList
Create class NodeId
Enregistre dans stack   m2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_4], TypeBoolean)
*** :
*** ptr1
*** ;
*** m
Create class NodeList
Create class NodeId
Enregistre dans stack   p TypeNamed_ptr1
*** :
*** Months
*** ;
*** r1
Create class NodeList
Create class NodeId
Enregistre dans stack   m TypeNamed_Months
*** :
*** range1
*** ;
*** r2
Create class NodeList
Create class NodeId
Enregistre dans stack   r1 TypeNamed_range1
*** :
*** range2
*** ;
*** month
Create class NodeList
Create class NodeId
Enregistre dans stack   r2 TypeNamed_range2
*** :
*** Months
*** ;
*** function
Create class NodeList
Create class NodeId
Enregistre dans stack   month TypeNamed_Months
*** goo
*** (
*** i
*** :
*** integer
*** ,
Create class NodeId
Create class NodeList
*** j
*** :
*** integer
*** )
Create class NodeId
*** :
*** boolean
*** ;
Enregistre goo ([i:TypeInt_null], [j:TypeInt_null]) -> TypeBoolean Defined: false Name: gooDeclare : 0
Create class NodeCallFct
*** //function goo(i : integer, j : integer) : boolean; //error "procedure or function declared twice"
*** function
Retrouve2 goo ([i:TypeInt_null], [j:TypeInt_null]) -> TypeBoolean Defined: false Name: gooDeclare : 0
Enregistre goo ([i:TypeInt_null], [j:TypeInt_null]) -> TypeBoolean Defined: false Name: gooDeclare : 1
Create class NodeList
*** foo
*** (
*** i
*** :
*** integer
*** ,
Create class NodeId
Create class NodeList
*** j
*** :
*** integer
*** )
Create class NodeId
*** :
*** ^
*** boolean
*** var
Enregistre foo ([i:TypeInt_null], [j:TypeInt_null]) -> TypePointer(TypeBoolean) Defined: false Name: fooDeclare : 0
Create class NodeCallFct
Stack PUSH
*** result
*** :
*** ^
*** boolean
*** ;
*** begin
Create class NodeList
Create class NodeId
Enregistre dans stack   result TypePointer(TypeBoolean)
Create class NodeList
*** new
*** result
*** ;
Retrouve dans stack   result TypePointer(TypeBoolean)
Retrouve dans stack   result TypePointer(TypeBoolean)
Retrouve dans stack   result TypePointer(TypeBoolean)
Retrouve dans stack   result TypePointer(TypeBoolean)
Retrouve dans stack   result TypePointer(TypeBoolean)
Create class NodeId
*** //result^ = hoo(i, j); // error "function not declared"
*** result
Create class NodeNew
Create class NodeList
*** ^
Retrouve dans stack   result TypePointer(TypeBoolean)
Retrouve dans stack   result TypePointer(TypeBoolean)
Retrouve dans stack   result TypePointer(TypeBoolean)
Retrouve dans stack   result TypePointer(TypeBoolean)
Retrouve dans stack   result TypePointer(TypeBoolean)
Create class NodeId
*** =
Create class NodePtrAccess
*** goo
*** (
*** i
*** ,
Create class NodeId
Create class NodeList
*** j
*** )
Create class NodeId
*** ;
Retrouve2 goo ([i:TypeInt_null], [j:TypeInt_null]) -> TypeBoolean Defined: false Name: gooDeclare : 1
Create class NodeCallFct
*** return
Create class NodeAssign
*** result
*** ;
Retrouve dans stack   result TypePointer(TypeBoolean)
Retrouve dans stack   result TypePointer(TypeBoolean)
Retrouve dans stack   result TypePointer(TypeBoolean)
Retrouve dans stack   result TypePointer(TypeBoolean)
Retrouve dans stack   result TypePointer(TypeBoolean)
Create class NodeId
*** end
Create class NodeReturn
*** function
Stack PUSH
Retrouve2 foo ([i:TypeInt_null], [j:TypeInt_null]) -> TypePointer(TypeBoolean) Defined: false Name: fooDeclare : 0
Enregistre foo ([i:TypeInt_null], [j:TypeInt_null]) -> TypePointer(TypeBoolean) Defined: true Name: fooDeclare : 1
*** goo
*** (
*** i
*** :
*** integer
*** ,
Create class NodeId
Create class NodeList
*** j
*** :
*** integer
*** )
Create class NodeId
*** :
*** boolean
*** begin
Create class NodeCallFct
Stack PUSH
*** return
*** (
*** i
*** +
Create class NodeId
*** j
*** )
Create class NodeId
Create class NodeOp
*** ;
*** end
Create class NodeReturn
Create class NodeList
*** //function goo(i : integer, j : integer) : boolean begin return false; end // error "function already defined"
*** begin
Stack PUSH
Retrouve2 goo ([i:TypeInt_null], [j:TypeInt_null]) -> TypeBoolean Defined: false Name: gooDeclare : 1
Enregistre goo ([i:TypeInt_null], [j:TypeInt_null]) -> TypeBoolean Defined: true Name: gooDeclare : 1
*** b
*** =
Retrouve dans stack   b TypeBoolean
Retrouve dans stack   b TypeBoolean
Retrouve dans stack   b TypeBoolean
Retrouve dans stack   b TypeBoolean
Retrouve dans stack   b TypeBoolean
Create class NodeId
*** false
*** ;
Create class NodeLiteral
*** //b = 2; // error "Type error in affectation"
*** //l = m2; // error "Type error in affectation"
*** l
Create class NodeAssign
Create class NodeList
*** =
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Create class NodeId
*** l
*** ;
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Create class NodeId
*** b
Create class NodeAssign
*** =
Retrouve dans stack   b TypeBoolean
Retrouve dans stack   b TypeBoolean
Retrouve dans stack   b TypeBoolean
Retrouve dans stack   b TypeBoolean
Retrouve dans stack   b TypeBoolean
Create class NodeId
*** foo
*** (
*** 3
*** ,
Create class NodeLiteral
Create class NodeList
*** 7
*** )
Create class NodeLiteral
*** ^
Retrouve2 foo ([i:TypeInt_null], [j:TypeInt_null]) -> TypePointer(TypeBoolean) Defined: true Name: fooDeclare : 1
Create class NodeCallFct
*** ;
Create class NodePtrAccess
*** b
Create class NodeAssign
*** =
Retrouve dans stack   b TypeBoolean
Retrouve dans stack   b TypeBoolean
Retrouve dans stack   b TypeBoolean
Retrouve dans stack   b TypeBoolean
Retrouve dans stack   b TypeBoolean
Create class NodeId
*** goo
*** (
*** 3
*** ,
Create class NodeLiteral
Create class NodeList
*** 7
*** )
Create class NodeLiteral
*** ;
Retrouve2 goo ([i:TypeInt_null], [j:TypeInt_null]) -> TypeBoolean Defined: true Name: gooDeclare : 1
Create class NodeCallFct
*** //b = foo(3); // error "Type error in calling expression"
*** //b = foo(3, false); // error "Type error in calling expression"
*** //x = foo(3, 7); // error "Type error in calling expression ??? ( plutot type error in affectation )
*** //z2 [ Thursday ] = 36; // error "Type error in array access "
*** z2
Create class NodeAssign
*** [
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Create class NodeId
*** 1
*** ]
Create class NodeLiteral
*** =
Create class NodeArrayAccess
*** 36
*** ;
Create class NodeLiteral
*** x
Create class NodeAssign
*** =
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Create class NodeId
*** z2
*** [
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Create class NodeId
*** 1
*** ]
Create class NodeLiteral
*** ;
Create class NodeArrayAccess
*** b
Create class NodeAssign
*** =
Retrouve dans stack   b TypeBoolean
Retrouve dans stack   b TypeBoolean
Retrouve dans stack   b TypeBoolean
Retrouve dans stack   b TypeBoolean
Retrouve dans stack   b TypeBoolean
Create class NodeId
*** goo
*** (
*** z2
*** [
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Create class NodeId
*** 1
*** ]
Create class NodeLiteral
*** ,
Create class NodeArrayAccess
Create class NodeList
*** 1
*** )
Create class NodeLiteral
*** ;
Retrouve2 goo ([i:TypeInt_null], [j:TypeInt_null]) -> TypeBoolean Defined: true Name: gooDeclare : 1
Create class NodeCallFct
*** //y = z2 [ false ]; // error "Type error in array access"
*** //y = z [ 4 ]; // error "Type error in affectation"
*** //b = z [ 4 ]; // error "Type error in affectation"
*** //z = k [ 4 ]; // error "Type error in affectation"
*** //b = z2 [ Thursday ]; // error "Type error in affectation"
*** //b = z2 [ 4 ]; // error "Type error in affectation"
*** //z2 = 36; // Accessible variable expected
*** if
Create class NodeAssign
*** (
*** l
*** [
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Create class NodeId
*** Monday
*** ]
Retrouve dans stack   Monday TypeItemEnum@Monday=1 nom :DaysOfWeek
Retrouve dans stack   Monday TypeItemEnum@Monday=1 nom :DaysOfWeek
Retrouve dans stack   Monday TypeItemEnum@Monday=1 nom :DaysOfWeek
Create class NodeId
*** )
Retrouve3 Monday TypeItemEnum@Monday=1 nom :DaysOfWeek
Retrouve3 Monday TypeItemEnum@Monday=1 nom :DaysOfWeek
Create class NodeArrayAccess
*** then
*** x
*** =
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Create class NodeId
*** 1
*** ;
Create class NodeLiteral
*** if
Create class NodeAssign
Create class NodeIf
*** (
*** l
*** [
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Create class NodeId
*** Monday
*** ]
Retrouve dans stack   Monday TypeItemEnum@Monday=1 nom :DaysOfWeek
Retrouve dans stack   Monday TypeItemEnum@Monday=1 nom :DaysOfWeek
Retrouve dans stack   Monday TypeItemEnum@Monday=1 nom :DaysOfWeek
Create class NodeId
*** )
Retrouve3 Monday TypeItemEnum@Monday=1 nom :DaysOfWeek
Retrouve3 Monday TypeItemEnum@Monday=1 nom :DaysOfWeek
Create class NodeArrayAccess
*** then
*** x
*** =
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Create class NodeId
*** 1
*** ;
Create class NodeLiteral
*** else
Create class NodeAssign
*** x
*** =
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Create class NodeId
*** 2
*** ;
Create class NodeLiteral
*** if
Create class NodeAssign
Create class NodeIf
*** (
*** z2
*** [
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Create class NodeId
*** 7
*** ]
Create class NodeLiteral
*** )
Create class NodeArrayAccess
*** then
*** x
*** =
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Create class NodeId
*** 1
*** ;
Create class NodeLiteral
*** while
Create class NodeAssign
Create class NodeIf
*** (
*** z2
*** [
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Create class NodeId
*** 7
*** ]
Create class NodeLiteral
*** )
Create class NodeArrayAccess
*** do
*** x
*** =
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Create class NodeId
*** 1
*** ;
Create class NodeLiteral
*** while
Create class NodeAssign
Create class NodeWhile
While ici NodeWhile(NodeArrayAccess(NodeId#z2:TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)#, NodeLiteral#7:TypeInt_7#), NodeAssign(NodeId#x:TypeInt_null#, NodeLiteral#1:TypeInt_1#))
*** (
*** z2
*** [
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Retrouve dans stack   z2 TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)
Create class NodeId
*** 7
*** ]
Create class NodeLiteral
*** )
Create class NodeArrayAccess
*** do
*** begin
Stack PUSH
*** if
*** (
*** l
*** [
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Retrouve dans stack   l TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)
Create class NodeId
*** Monday
*** ]
Retrouve dans stack   Monday TypeItemEnum@Monday=1 nom :DaysOfWeek
Retrouve dans stack   Monday TypeItemEnum@Monday=1 nom :DaysOfWeek
Retrouve dans stack   Monday TypeItemEnum@Monday=1 nom :DaysOfWeek
Create class NodeId
*** )
Retrouve3 Monday TypeItemEnum@Monday=1 nom :DaysOfWeek
Retrouve3 Monday TypeItemEnum@Monday=1 nom :DaysOfWeek
Create class NodeArrayAccess
*** then
*** x
*** =
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Create class NodeId
*** 1
*** ;
Create class NodeLiteral
*** else
Create class NodeAssign
*** x
*** =
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Create class NodeId
*** 2
*** ;
Create class NodeLiteral
*** println
Create class NodeAssign
Create class NodeIf
Create class NodeList
*** x
*** ;
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Create class NodeId
*** readln
Create class NodeList
Create class NodeCallFct
*** y
*** ;
Retrouve dans stack   y TypeInt_null
Retrouve dans stack   y TypeInt_null
Retrouve dans stack   y TypeInt_null
Retrouve dans stack   y TypeInt_null
Retrouve dans stack   y TypeInt_null
Create class NodeId
*** end
Create class NodeList
Create class NodeCallFct
*** switch
Stack PUSH
Create class NodeWhile
While ici NodeWhile(NodeArrayAccess(NodeId#z2:TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)#, NodeLiteral#7:TypeInt_7#), NodeList(NodeIf(NodeArrayAccess(NodeId#l:TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)#, NodeId#Monday:TypeInt_1#), NodeAssign(NodeId#x:TypeInt_null#, NodeLiteral#1:TypeInt_1#), NodeAssign(NodeId#x:TypeInt_null#, NodeLiteral#2:TypeInt_2#)), println_NodeCallFct(NodeList(NodeId#x:TypeInt_null#)), readln_NodeCallFct(NodeList(NodeId#y:TypeInt_null#))))
*** (
*** month
*** )
Retrouve dans stack   month TypeNamed_Months
Retrouve dans stack   month TypeNamed_Months
Retrouve dans stack   month TypeNamed_Months
Retrouve dans stack   month TypeNamed_Months
Retrouve dans stack   month TypeNamed_Months
Retrouve1 Months TypeEnumRange[TypeItemEnum@January=0 nom :..TypeItemEnum@December=11 nom :]_1
Create class NodeId
*** begin
*** case
*** March
*** ,
*** April
*** ,
*** May
*** :
*** println
*** (
*** "spring"
*** )
Create class NodeLiteral
*** ;
*** case
Create class NodeList
Create class NodeCallFct
Create class NodeList
Create class NodeCase
Create class NodeCase
Create class NodeCase
Create class NodeCaseList
*** June
*** ,
*** July
*** ,
*** August
*** :
*** println
*** (
*** "summer"
*** )
Create class NodeLiteral
*** ;
*** case
Create class NodeList
Create class NodeCallFct
Create class NodeList
Create class NodeCase
Create class NodeCase
Create class NodeCase
*** September
*** ,
*** October
*** ,
*** November
*** :
*** println
*** (
*** "autumn"
*** )
Create class NodeLiteral
*** ;
*** case
Create class NodeList
Create class NodeCallFct
Create class NodeList
Create class NodeCase
Create class NodeCase
Create class NodeCase
*** February
*** ,
*** December
*** ,
*** January
*** :
*** println
*** (
*** "winter"
*** )
Create class NodeLiteral
*** ;
*** default
Create class NodeList
Create class NodeCallFct
Create class NodeList
Create class NodeCase
Create class NodeCase
Create class NodeCase
*** :
*** println
*** (
*** "none"
*** )
Create class NodeLiteral
*** ;
*** end
Create class NodeList
Create class NodeCallFct
Create class NodeCase
*** x
Create class NodeSwitch
*** =
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Create class NodeId
*** -
*** (
*** 36
*** +
Create class NodeLiteral
*** 45
*** /
Create class NodeLiteral
Create class NodeOp
*** 7
*** )
Create class NodeLiteral
Create class NodeOp
*** ;
Create class NodeOp
*** //b = !(2 < false) && (x == 1) && (p == null); // // error "Type error in comparison"
*** //b = !(2 < x) && (x == 1) && p ; // // error "Type error in logical expression"
*** //b = !(2 < x) && (x == 1 + false) && p ; // // error "Type error in arithmetic expression"
*** p
Create class NodeAssign
*** =
Retrouve dans stack   p TypeNamed_ptr1
Retrouve dans stack   p TypeNamed_ptr1
Retrouve dans stack   p TypeNamed_ptr1
Retrouve dans stack   p TypeNamed_ptr1
Retrouve dans stack   p TypeNamed_ptr1
Retrouve1 ptr1 TypePointer(TypeInt_null)
Create class NodeId
*** null
*** ;
Create class NodeLiteral
*** //p = 0; // error "Type error in affectation"
*** new
Create class NodeLiteral
Create class NodeAssign
*** p
*** ;
Retrouve dans stack   p TypeNamed_ptr1
Retrouve dans stack   p TypeNamed_ptr1
Retrouve dans stack   p TypeNamed_ptr1
Retrouve dans stack   p TypeNamed_ptr1
Retrouve dans stack   p TypeNamed_ptr1
Retrouve1 ptr1 TypePointer(TypeInt_null)
Create class NodeId
*** //new x; // error "Type error in pointer access expression"
*** p
Create class NodeNew
*** ^
Retrouve dans stack   p TypeNamed_ptr1
Retrouve dans stack   p TypeNamed_ptr1
Retrouve dans stack   p TypeNamed_ptr1
Retrouve dans stack   p TypeNamed_ptr1
Retrouve dans stack   p TypeNamed_ptr1
Retrouve1 ptr1 TypePointer(TypeInt_null)
Create class NodeId
*** =
Create class NodePtrAccess
*** 36
*** ;
Create class NodeLiteral
*** //p^ = false; //error "TypeInt != TypeBoolean"
*** //x^ = null; // error "Type error in pointer access expression"
*** x
Create class NodeAssign
*** =
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Retrouve dans stack   x TypeInt_null
Create class NodeId
*** p
*** ^
Retrouve dans stack   p TypeNamed_ptr1
Retrouve dans stack   p TypeNamed_ptr1
Retrouve dans stack   p TypeNamed_ptr1
Retrouve dans stack   p TypeNamed_ptr1
Retrouve dans stack   p TypeNamed_ptr1
Retrouve1 ptr1 TypePointer(TypeInt_null)
Create class NodeId
*** ;
Create class NodePtrAccess
*** dispose
Create class NodeAssign
*** p
*** ;
Retrouve dans stack   p TypeNamed_ptr1
Retrouve dans stack   p TypeNamed_ptr1
Retrouve dans stack   p TypeNamed_ptr1
Retrouve dans stack   p TypeNamed_ptr1
Retrouve dans stack   p TypeNamed_ptr1
Retrouve1 ptr1 TypePointer(TypeInt_null)
Create class NodeId
*** //dispose x;  // error "Type error in pointer access expression"
*** end
Create class NodeDispose

Stack PUSH
NodeList(NodeAssign(NodeId#b:TypeBoolean#, NodeLiteral#false:TypeBoolean#), NodeAssign(NodeId#l:TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)#, NodeId#l:TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)#), NodeAssign(NodeId#b:TypeBoolean#, NodePtrAccess(foo_NodeCallFct(NodeList(NodeLiteral#3:TypeInt_3#, NodeLiteral#7:TypeInt_7#)))), NodeAssign(NodeId#b:TypeBoolean#, goo_NodeCallFct(NodeList(NodeLiteral#3:TypeInt_3#, NodeLiteral#7:TypeInt_7#))), NodeAssign(NodeArrayAccess(NodeId#z2:TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)#, NodeLiteral#1:TypeInt_1#), NodeLiteral#36:TypeInt_36#), NodeAssign(NodeId#x:TypeInt_null#, NodeArrayAccess(NodeId#z2:TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)#, NodeLiteral#1:TypeInt_1#)), NodeAssign(NodeId#b:TypeBoolean#, goo_NodeCallFct(NodeList(NodeArrayAccess(NodeId#z2:TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)#, NodeLiteral#1:TypeInt_1#), NodeLiteral#1:TypeInt_1#))), NodeIf(NodeArrayAccess(NodeId#l:TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)#, NodeId#Monday:TypeInt_1#), NodeAssign(NodeId#x:TypeInt_null#, NodeLiteral#1:TypeInt_1#)), NodeIf(NodeArrayAccess(NodeId#l:TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)#, NodeId#Monday:TypeInt_1#), NodeAssign(NodeId#x:TypeInt_null#, NodeLiteral#1:TypeInt_1#), NodeAssign(NodeId#x:TypeInt_null#, NodeLiteral#2:TypeInt_2#)), NodeIf(NodeArrayAccess(NodeId#z2:TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)#, NodeLiteral#7:TypeInt_7#), NodeAssign(NodeId#x:TypeInt_null#, NodeLiteral#1:TypeInt_1#)), NodeWhile(NodeArrayAccess(NodeId#z2:TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)#, NodeLiteral#7:TypeInt_7#), NodeAssign(NodeId#x:TypeInt_null#, NodeLiteral#1:TypeInt_1#)), NodeWhile(NodeArrayAccess(NodeId#z2:TypeArray(TypeArrayRange[TypeInt_1..TypeInt_32], TypeInt_null)#, NodeLiteral#7:TypeInt_7#), NodeList(NodeIf(NodeArrayAccess(NodeId#l:TypeArray(TypeArrayRange[TypeInt_1..TypeInt_5], TypeBoolean)#, NodeId#Monday:TypeInt_1#), NodeAssign(NodeId#x:TypeInt_null#, NodeLiteral#1:TypeInt_1#), NodeAssign(NodeId#x:TypeInt_null#, NodeLiteral#2:TypeInt_2#)), println_NodeCallFct(NodeList(NodeId#x:TypeInt_null#)), readln_NodeCallFct(NodeList(NodeId#y:TypeInt_null#)))), NodeSwitch(NodeId#month:TypeEnumRange[TypeItemEnum@January=0 nom :..TypeItemEnum@December=11 nom :]_1#, NodeCaseList(NodeList(NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"spring":TypeString#))), NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"spring":TypeString#))), NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"spring":TypeString#)))), NodeList(NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"summer":TypeString#))), NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"summer":TypeString#))), NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"summer":TypeString#)))), NodeList(NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"autumn":TypeString#))), NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"autumn":TypeString#))), NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"autumn":TypeString#)))), NodeList(NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"winter":TypeString#))), NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"winter":TypeString#))), NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"winter":TypeString#)))), NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"none":TypeString#))))), NodeAssign(NodeId#x:TypeInt_null#, NodeOp(NodeOp(NodeOp(NodeLiteral#36:TypeInt_36#, NodeLiteral#45:TypeInt_45#), NodeLiteral#7:TypeInt_7#))), NodeAssign(NodeId#p:TypePointer(TypeInt_null)#, NodeLiteral#0:TypePointer(TypeInt_null)#), NodeNew(NodeId#p:TypePointer(TypeInt_null)#), NodeAssign(NodePtrAccess(NodeId#p:TypePointer(TypeInt_null)#), NodeLiteral#36:TypeInt_36#), NodeAssign(NodeId#x:TypeInt_null#, NodePtrAccess(NodeId#p:TypePointer(TypeInt_null)#)), NodeDispose(NodeId#p:TypePointer(TypeInt_null)#))
Créer code intermédiaire
--- CheckType NodeList
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeId
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodePtrAccess
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeCallFct
--- CheckType NodeLiteral
--- CheckType NodeLiteral
--- CheckType NodeAssign
--- CheckType NodeArrayAccess
--- CheckType NodeLiteral
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeArrayAccess
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeCallFct
--- CheckType NodeArrayAccess
--- CheckType NodeLiteral
--- CheckType NodeIf
--- CheckType NodeIf
--- CheckType NodeIf
--- CheckType NodeWhile
--- CheckType NodeArrayAccess
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
--- CheckType NodeWhile
--- CheckType NodeArrayAccess
--- CheckType NodeList
--- CheckType NodeIf
--- CheckType NodeCallFct
--- CheckType NodeId
--- CheckType NodeCallFct
--- CheckType NodeId
--- CheckType NodeSwitch
--- CheckType NodeId
--- CheckType NodeCaseList
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeOp
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
--- CheckType NodeNew
--- CheckType NodeAssign
--- CheckType NodePtrAccess
--- CheckType NodeLiteral
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodePtrAccess
--- CheckType NodeDispose
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
--- CheckType NodeId
Name ( LabelLocation(b) )
--- CheckType NodeLiteral
NodeAssign =>Move ( Mem ( Name ( LabelLocation(b) ) ), Const ( 0 ) )
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeId
--- CheckType NodeId
Name ( LabelLocation(l) )
--- CheckType NodeId
Name ( LabelLocation(l) )
NodeAssign =>Move ( Mem ( Name ( LabelLocation(l) ) ), Name ( LabelLocation(l) ) )
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodePtrAccess
--- CheckType NodeId
Name ( LabelLocation(b) )
--- CheckType NodePtrAccess
--- CheckType NodeCallFct
--- CheckType NodeLiteral
--- CheckType NodeLiteral
--- CheckType NodeList
--- CheckType NodeLiteral
--- CheckType NodeLiteral
--- CheckType NodeLiteral
--- CheckType NodeLiteral
ExpStm ( Const ( 3 ) )
Callfct =>Call( Name ( LabelLocation(foo) ), ExpList ( Const ( 3 ), Const ( 7 ) ) )
NodePtrAcces => Mem ( Call( Name ( LabelLocation(foo) ), ExpList ( Const ( 3 ), Const ( 7 ) ) ) )
NodeAssign =>Move ( Mem ( Name ( LabelLocation(b) ) ), Mem ( Call( Name ( LabelLocation(foo) ), ExpList ( Const ( 3 ), Const ( 7 ) ) ) ) )
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeCallFct
--- CheckType NodeLiteral
--- CheckType NodeLiteral
--- CheckType NodeId
Name ( LabelLocation(b) )
--- CheckType NodeCallFct
--- CheckType NodeLiteral
--- CheckType NodeLiteral
--- CheckType NodeList
--- CheckType NodeLiteral
--- CheckType NodeLiteral
--- CheckType NodeLiteral
--- CheckType NodeLiteral
ExpStm ( Const ( 3 ) )
Callfct =>Call( Name ( LabelLocation(goo) ), ExpList ( Const ( 3 ), Const ( 7 ) ) )
NodeAssign =>Move ( Mem ( Name ( LabelLocation(b) ) ), Call( Name ( LabelLocation(goo) ), ExpList ( Const ( 3 ), Const ( 7 ) ) ) )
--- CheckType NodeAssign
--- CheckType NodeArrayAccess
--- CheckType NodeLiteral
--- CheckType NodeArrayAccess
--- CheckType NodeId
Name ( LabelLocation(z2) )
--- CheckType NodeLiteral
NodeArrayAcces => Mem ( Binop(Name ( LabelLocation(z2) ),PLUS,Binop(Const ( 4 ),MUL,Name ( LabelLocation(z2) ))) )
--- CheckType NodeLiteral
NodeAssign =>Move ( Mem ( Mem ( Binop(Name ( LabelLocation(z2) ),PLUS,Binop(Const ( 4 ),MUL,Name ( LabelLocation(z2) ))) ) ), Const ( 36 ) )
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeArrayAccess
--- CheckType NodeId
Name ( LabelLocation(x) )
--- CheckType NodeArrayAccess
--- CheckType NodeId
Name ( LabelLocation(z2) )
--- CheckType NodeLiteral
NodeArrayAcces => Mem ( Binop(Name ( LabelLocation(z2) ),PLUS,Binop(Const ( 4 ),MUL,Name ( LabelLocation(z2) ))) )
NodeAssign =>Move ( Mem ( Name ( LabelLocation(x) ) ), Mem ( Binop(Name ( LabelLocation(z2) ),PLUS,Binop(Const ( 4 ),MUL,Name ( LabelLocation(z2) ))) ) )
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeCallFct
--- CheckType NodeArrayAccess
--- CheckType NodeLiteral
--- CheckType NodeId
Name ( LabelLocation(b) )
--- CheckType NodeCallFct
--- CheckType NodeArrayAccess
--- CheckType NodeLiteral
--- CheckType NodeList
--- CheckType NodeArrayAccess
--- CheckType NodeLiteral
--- CheckType NodeArrayAccess
--- CheckType NodeId
Name ( LabelLocation(z2) )
--- CheckType NodeLiteral
NodeArrayAcces => Mem ( Binop(Name ( LabelLocation(z2) ),PLUS,Binop(Const ( 4 ),MUL,Name ( LabelLocation(z2) ))) )
--- CheckType NodeLiteral
ExpStm ( Mem ( Binop(Name ( LabelLocation(z2) ),PLUS,Binop(Const ( 4 ),MUL,Name ( LabelLocation(z2) ))) ) )
Callfct =>Call( Name ( LabelLocation(goo) ), ExpList ( Mem ( Binop(Name ( LabelLocation(z2) ),PLUS,Binop(Const ( 4 ),MUL,Name ( LabelLocation(z2) ))) ), Const ( 1 ) ) )
NodeAssign =>Move ( Mem ( Name ( LabelLocation(b) ) ), Call( Name ( LabelLocation(goo) ), ExpList ( Mem ( Binop(Name ( LabelLocation(z2) ),PLUS,Binop(Const ( 4 ),MUL,Name ( LabelLocation(z2) ))) ), Const ( 1 ) ) ) )
--- CheckType NodeIf
--- CheckType NodeArrayAccess
--- CheckType NodeId
Name ( LabelLocation(l) )
--- CheckType NodeId
Name ( LabelLocation(Monday) )
NodeArrayAcces => Mem ( Binop(Name ( LabelLocation(l) ),PLUS,Binop(Const ( 1 ),MUL,Name ( LabelLocation(l) ))) )
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
--- CheckType NodeId
Name ( LabelLocation(x) )
--- CheckType NodeLiteral
NodeAssign =>Move ( Mem ( Name ( LabelLocation(x) ) ), Const ( 1 ) )
Seq ( Cjump ( bad relop in CJUMP, Mem ( Binop(Name ( LabelLocation(l) ),PLUS,Binop(Const ( 1 ),MUL,Name ( LabelLocation(l) ))) ), Const ( 0 ), LabelLocation(L0), LabelLocation(L1) ), Seq ( Seq ( Label ( LabelLocation(L0) ), Move ( Mem ( Name ( LabelLocation(x) ) ), Const ( 1 ) ) ), Label ( LabelLocation(L1) ) ) )
--- CheckType NodeIf
--- CheckType NodeArrayAccess
--- CheckType NodeId
Name ( LabelLocation(l) )
--- CheckType NodeId
Name ( LabelLocation(Monday) )
NodeArrayAcces => Mem ( Binop(Name ( LabelLocation(l) ),PLUS,Binop(Const ( 1 ),MUL,Name ( LabelLocation(l) ))) )
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
--- CheckType NodeId
Name ( LabelLocation(x) )
--- CheckType NodeLiteral
NodeAssign =>Move ( Mem ( Name ( LabelLocation(x) ) ), Const ( 1 ) )
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
--- CheckType NodeId
Name ( LabelLocation(x) )
--- CheckType NodeLiteral
NodeAssign =>Move ( Mem ( Name ( LabelLocation(x) ) ), Const ( 2 ) )
Seq ( Seq ( Cjump ( bad relop in CJUMP, Mem ( Binop(Name ( LabelLocation(l) ),PLUS,Binop(Const ( 1 ),MUL,Name ( LabelLocation(l) ))) ), Const ( 0 ), LabelLocation(L2), LabelLocation(L3) ), Seq ( Seq ( Seq ( Label ( LabelLocation(L2) ), Move ( Mem ( Name ( LabelLocation(x) ) ), Const ( 1 ) ) ), Jump ( Name ( LabelLocation(L4) ), LabelLocationList ( LabelLocation(L4) ) ) ), Seq ( Seq ( Label ( LabelLocation(L3) ), Move ( Mem ( Name ( LabelLocation(x) ) ), Const ( 2 ) ) ), Jump ( Name ( LabelLocation(L4) ), LabelLocationList ( LabelLocation(L4) ) ) ) ) ), Label ( LabelLocation(L4) ) )
--- CheckType NodeIf
--- CheckType NodeArrayAccess
--- CheckType NodeId
Name ( LabelLocation(z2) )
--- CheckType NodeLiteral
NodeArrayAcces => Mem ( Binop(Name ( LabelLocation(z2) ),PLUS,Binop(Const ( 4 ),MUL,Name ( LabelLocation(z2) ))) )
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
--- CheckType NodeId
Name ( LabelLocation(x) )
--- CheckType NodeLiteral
NodeAssign =>Move ( Mem ( Name ( LabelLocation(x) ) ), Const ( 1 ) )
Seq ( Cjump ( bad relop in CJUMP, Mem ( Binop(Name ( LabelLocation(z2) ),PLUS,Binop(Const ( 4 ),MUL,Name ( LabelLocation(z2) ))) ), Const ( 0 ), LabelLocation(L5), LabelLocation(L6) ), Seq ( Seq ( Label ( LabelLocation(L5) ), Move ( Mem ( Name ( LabelLocation(x) ) ), Const ( 1 ) ) ), Label ( LabelLocation(L6) ) ) )
--- CheckType NodeWhile
--- CheckType NodeArrayAccess
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
CI : NodeWhile
--- CheckType NodeArrayAccess
--- CheckType NodeId
Name ( LabelLocation(z2) )
--- CheckType NodeLiteral
NodeArrayAcces => Mem ( Binop(Name ( LabelLocation(z2) ),PLUS,Binop(Const ( 4 ),MUL,Name ( LabelLocation(z2) ))) )
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
--- CheckType NodeId
Name ( LabelLocation(x) )
--- CheckType NodeLiteral
NodeAssign =>Move ( Mem ( Name ( LabelLocation(x) ) ), Const ( 1 ) )
NodeWhile =>Seq ( Seq ( Label ( LabelLocation(L8) ), Cjump ( bad relop in CJUMP, Mem ( Binop(Name ( LabelLocation(z2) ),PLUS,Binop(Const ( 4 ),MUL,Name ( LabelLocation(z2) ))) ), Const ( 0 ), LabelLocation(L7), LabelLocation(L9) ) ), Seq ( Seq ( Seq ( Label ( LabelLocation(L7) ), Move ( Mem ( Name ( LabelLocation(x) ) ), Const ( 1 ) ) ), Jump ( Name ( LabelLocation(L8) ), LabelLocationList ( LabelLocation(L8) ) ) ), Label ( LabelLocation(L9) ) ) )
--- CheckType NodeWhile
--- CheckType NodeArrayAccess
--- CheckType NodeList
--- CheckType NodeIf
--- CheckType NodeCallFct
--- CheckType NodeId
--- CheckType NodeCallFct
--- CheckType NodeId
CI : NodeWhile
--- CheckType NodeArrayAccess
--- CheckType NodeId
Name ( LabelLocation(z2) )
--- CheckType NodeLiteral
NodeArrayAcces => Mem ( Binop(Name ( LabelLocation(z2) ),PLUS,Binop(Const ( 4 ),MUL,Name ( LabelLocation(z2) ))) )
--- CheckType NodeList
--- CheckType NodeIf
--- CheckType NodeCallFct
--- CheckType NodeId
--- CheckType NodeCallFct
--- CheckType NodeId
--- CheckType NodeIf
--- CheckType NodeArrayAccess
--- CheckType NodeId
Name ( LabelLocation(l) )
--- CheckType NodeId
Name ( LabelLocation(Monday) )
NodeArrayAcces => Mem ( Binop(Name ( LabelLocation(l) ),PLUS,Binop(Const ( 1 ),MUL,Name ( LabelLocation(l) ))) )
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
--- CheckType NodeId
Name ( LabelLocation(x) )
--- CheckType NodeLiteral
NodeAssign =>Move ( Mem ( Name ( LabelLocation(x) ) ), Const ( 1 ) )
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
--- CheckType NodeId
Name ( LabelLocation(x) )
--- CheckType NodeLiteral
NodeAssign =>Move ( Mem ( Name ( LabelLocation(x) ) ), Const ( 2 ) )
Seq ( Seq ( Cjump ( bad relop in CJUMP, Mem ( Binop(Name ( LabelLocation(l) ),PLUS,Binop(Const ( 1 ),MUL,Name ( LabelLocation(l) ))) ), Const ( 0 ), LabelLocation(L10), LabelLocation(L11) ), Seq ( Seq ( Seq ( Label ( LabelLocation(L10) ), Move ( Mem ( Name ( LabelLocation(x) ) ), Const ( 1 ) ) ), Jump ( Name ( LabelLocation(L12) ), LabelLocationList ( LabelLocation(L12) ) ) ), Seq ( Seq ( Label ( LabelLocation(L11) ), Move ( Mem ( Name ( LabelLocation(x) ) ), Const ( 2 ) ) ), Jump ( Name ( LabelLocation(L12) ), LabelLocationList ( LabelLocation(L12) ) ) ) ) ), Label ( LabelLocation(L12) ) )
--- CheckType NodeCallFct
--- CheckType NodeId
--- CheckType NodeList
--- CheckType NodeId
--- CheckType NodeId
Name ( LabelLocation(x) )
ExpStm ( Name ( LabelLocation(x) ) )
Callfct =>Call( Name ( LabelLocation(println) ), ExpList ( Name ( LabelLocation(x) ) ) )
--- CheckType NodeCallFct
--- CheckType NodeId
--- CheckType NodeList
--- CheckType NodeId
--- CheckType NodeId
Name ( LabelLocation(y) )
ExpStm ( Name ( LabelLocation(y) ) )
Callfct =>Call( Name ( LabelLocation(readln) ), ExpList ( Name ( LabelLocation(y) ) ) )
Seq ( Seq ( Cjump ( bad relop in CJUMP, Mem ( Binop(Name ( LabelLocation(l) ),PLUS,Binop(Const ( 1 ),MUL,Name ( LabelLocation(l) ))) ), Const ( 0 ), LabelLocation(L10), LabelLocation(L11) ), Seq ( Seq ( Seq ( Label ( LabelLocation(L10) ), Move ( Mem ( Name ( LabelLocation(x) ) ), Const ( 1 ) ) ), Jump ( Name ( LabelLocation(L12) ), LabelLocationList ( LabelLocation(L12) ) ) ), Seq ( Seq ( Label ( LabelLocation(L11) ), Move ( Mem ( Name ( LabelLocation(x) ) ), Const ( 2 ) ) ), Jump ( Name ( LabelLocation(L12) ), LabelLocationList ( LabelLocation(L12) ) ) ) ) ), Label ( LabelLocation(L12) ) )
NodeWhile =>Seq ( Seq ( Label ( LabelLocation(L14) ), Cjump ( bad relop in CJUMP, Mem ( Binop(Name ( LabelLocation(z2) ),PLUS,Binop(Const ( 4 ),MUL,Name ( LabelLocation(z2) ))) ), Const ( 0 ), LabelLocation(L13), LabelLocation(L15) ) ), Seq ( Seq ( Seq ( Label ( LabelLocation(L13) ), Seq ( Seq ( Cjump ( bad relop in CJUMP, Mem ( Binop(Name ( LabelLocation(l) ),PLUS,Binop(Const ( 1 ),MUL,Name ( LabelLocation(l) ))) ), Const ( 0 ), LabelLocation(L10), LabelLocation(L11) ), Seq ( Seq ( Seq ( Label ( LabelLocation(L10) ), Move ( Mem ( Name ( LabelLocation(x) ) ), Const ( 1 ) ) ), Jump ( Name ( LabelLocation(L12) ), LabelLocationList ( LabelLocation(L12) ) ) ), Seq ( Seq ( Label ( LabelLocation(L11) ), Move ( Mem ( Name ( LabelLocation(x) ) ), Const ( 2 ) ) ), Jump ( Name ( LabelLocation(L12) ), LabelLocationList ( LabelLocation(L12) ) ) ) ) ), Label ( LabelLocation(L12) ) ) ), Jump ( Name ( LabelLocation(L14) ), LabelLocationList ( LabelLocation(L14) ) ) ), Label ( LabelLocation(L15) ) ) )
--- CheckType NodeSwitch
--- CheckType NodeId
--- CheckType NodeCaseList
3333333 fils Switch size2
3333333 fils Switch NodeId#month:TypeEnumRange[TypeItemEnum@January=0 nom :..TypeItemEnum@December=11 nom :]_1#
--- CheckType NodeId
Name ( LabelLocation(month) )
3333333 fils Switch NodeCaseList(NodeList(NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"spring":TypeString#))), NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"spring":TypeString#))), NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"spring":TypeString#)))), NodeList(NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"summer":TypeString#))), NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"summer":TypeString#))), NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"summer":TypeString#)))), NodeList(NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"autumn":TypeString#))), NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"autumn":TypeString#))), NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"autumn":TypeString#)))), NodeList(NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"winter":TypeString#))), NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"winter":TypeString#))), NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"winter":TypeString#)))), NodeCase(println_NodeCallFct(NodeList(NodeLiteral#"none":TypeString#))))
--- CheckType NodeCaseList
--- CheckType NodeList
--- CheckType NodeCase
--- CheckType NodeCase
--- CheckType NodeCase
--- CheckType NodeCase
